[{"title":"JS知识点总结","slug":"JS知识点总结","date":"2019-11-01T09:19:59.000Z","updated":"2019-11-15T12:00:50.289Z","comments":true,"path":"2019/11/01/JS知识点总结/","link":"","permalink":"http://yoursite.com/2019/11/01/JS知识点总结/","excerpt":"JavaScript的知识点总结","text":"JavaScript的知识点总结 JS中常用的数据类型 基本数据类型 数字number 常规数字和NaN 字符串string 所有用单引号、双引号、反引号（撇）包起来的都是字符串 布尔boolean true/false 空对象指针null 未定义undefined 引用数据类型 对象数据类型object {} 普通对象 [] 数组对象 正则对象 Math数学函数对象 日期对象 … 函数数据类型function number数字类型 包含：常规数字、NaN 数字类型的范围:Number.MIN_VALUE == -InfinityNumber.MAX_VALUE == Infinity NaN not a number：不是一个数，但它隶属于数字类型 NaN和任何值（包括自己）都不相等：NaN!=NaN，所以我们不能用相等的方式判断是否为有效数字 isNaN 检测一个值是否为非有效数字，如果不是有效数字返回TRUE，反之是有效数字返回FALSE 在使用isNaN进行检测的时候，首先会验证检测的值是否为数字类型，如果不是，先基于Number()这个方法，把值转换为数字类型，然后再检测 把其它类型值转换为数字类型 Number([val]): 把字符串转换为数字，只要字符串中包含任意一个非有效数字字符（第一个点除外）结果都是NaN，空字符串会变为数字零 parseInt/parseFloat([val],[进制])：也是转换为数字的方法，对于字符串来说，它是从左到右依次查找有效数字字符，直到遇到非有效数字字符，停止查找（不管后面是否还有数字，都不在找了），把找到的当做数字返回 ==进行比较的时候，可能要出现把其它类型值转换为数字 string字符串数据类型 所有用单引号、双引号、反引号（撇 ES6模板字符串）包起来的都是字符串 把其它类型值转换为字符串 [val].toString() 字符串拼接12345678910let a = 10 + null + true + [] + undefined + '珠峰' + null + [] + 10 + false;/* * 10 + null -&gt; 10 + 0 -&gt; 10 * 10 + true -&gt; 10 + 1 -&gt; 11 * 11 + [] -&gt; 11 + '' -&gt; '11' 空数组变为数字，先要经历变为空字符串，遇到字符串，啥都别想了，直接变为字符串拼接 * '11' + undefined -&gt; '11undefined' * ... * '11undefined珠峰null10false' */console.log(a); boolean布尔数据类型 只有两个值 true/false 把其它类型值转换为布尔类型 只有 0、NaN、’’、null、undefined 五个值转换为FALSE，其余都转换为TRUE（而且没有任何的特殊情况） Boolean([val]) !/!! 条件判断 null / undefined null和undefined都代表的是没有 null：意料之中（一般都是开始不知道值，我们手动先设置为null，后期再给予赋值操作） undefined：意料之外（不是我能决定的）在声明变量但未对其加以初始化时的值 object对象数据类型-普通对象 {[key]:[value],…} 任何一个对象都是由零到多组键值对（属性名：属性值）组成的（并且属性名不能重复）,就是一组数据和功能的集合。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748let person = &#123; name: '易烊千玺', age: 40, height: '185CM', weight: '80KG', 1: 100&#125;;// 删除属性/* // =&gt;真删除：把属性彻底干掉delete person[1];// =&gt;假删除：属性还在，值为空person.weight = null;console.log(person); */// 设置属性名属性值// =&gt;属性名不能重复，如果属性名已经存在，不属于新增属于修改属性值/* person.GF = '园园';person.name = '李易峰';console.log(person['GF']);console.log(person['name']); */// 获取属性名对应的属性值// =&gt;对象.属性名// =&gt;对象[属性名] 属性名是数字或者字符串格式的// =&gt;如果当前属性名不存在，默认的属性值是undefined// =&gt;如果属性名是数字，则不能使用点的方式获取属性值/* console.log(person.name);console.log(person['age']);console.log(person.sex); //=&gt;undefinedconsole.log(person[1]);// console.log(person.1); //=&gt;SyntaxError:语法错误 *//* * 数组是特殊的对象 * 1. 我们中括号中设置的是属性值，它的属性名是默认生成的数字，从零开始递增，而且这个数字代表每一项的位置，我们把其成为“索引” =&gt;从零开始，连续递增，代表每一项位置的数字属性名 * 2. 天生默认一个属性名 length ，存储数组的长度 */let ary = [12, '哈哈', true, 13];/* console.log(ary.length);console.log(ary['length']);console.log(ary[1]);// 第一项索引0 最后一项索引 ary.length-1console.log(ary[0]);console.log(ary[ary.length - 1]); */// 向数组末尾追加内容ary[ary.length] = 100;console.log(ary); JS中的数据类型检测 typeof [val]：用来检测数据类型的运算符 instanceof ：用来检测当前实例是否率属于某个类 constructor ： 基于构造函数检测数据类型（也是基于类的方式） Object.prototype.toString.call() ：检测数据类型最好的办法 基于typeof检测出来的结果 1.首先是一个字符串 2.字符串中包含对应的类型 局限性 1.typeof null =&gt; “object” 但是null并不是对象 2.基于typeof无法细分出当前值是普通对象还是数组对象等，因为只要是对象数据类型，返回的结果都是”object” JS中的操作语句：判断、循环判断 if/else if/else 三元运算符：简单IF/ELSE的特殊处理方式条件?条件成立处理的事情:不成立处理的事情; 1.如果处理的事情比较多，我们用括号包起来，每一件事情用逗号分隔2.如果不需要处理事情，可以使用null/undefined占位 switch case：一个变量在不同值情况下的不同操作 1.每一种CASE情况结束后最好都加上BREAK2.default等价于else，以上都不成立干的事情3.每一种case情况的比较用的都是===“绝对相等” 不加break，当前条件成立执行完成后，后面条件不论是否成立都要执行，直到遇到break为止（不加break可以实现变量在某些值的情况下做相同的事情 if/else 123456789if(条件)&#123; 条件成立执行&#125;else if(条件2)&#123; 条件2成立执行&#125;...else&#123; 以上条件都不成立&#125; == VS =====：相等（如果左右两边数据值类型不同，是默认先转换为相同的类型，然后比较）‘5’==5 =&gt;TRUE ===：绝对相等（如果类型不一样，肯定不相等，不会默认转换数据类型）‘5’===5 =&gt;FALSE 项目中为了保证业务的严谨，推荐使用=== 循环 重复做某些事情就是循环 for循环 for in循环 在遍历的时候优先遍历数字的属性名 for of循环（ES6新增） while循环 do while循环循环体中的两个关键词continue：结束当前这轮循环（continue后面的代码不再执行），继续执行下一轮循环break: 强制结束整个循环（break后面代码也不再执行），而且整个循环啥也不干直接结束 函数 function 函数就是一个方法或者一个功能体，函数就是把实现某个功能的代码放到一起进行分装，以后想要操作实现这个功能，只需要把函数执行即可 =&gt;“封装”：减少页面中的冗余代码，提高代码重复使用率（低耦合高内聚） 创建函数 形参 n/m是形参，是变量，用来存储执行函数时传递的实参创建函数的时候我们设置了形参变量，但如果执行的时候并没有给传递对应的实参值，那么形参变量默认的值是：undefined 返回值1.函数执行的时候，函数体内部创建的变量我们是无法获取和操作的，如果要想获取内部的信息，我们需要基于RETURN返回值机制，把信息回才可以2.没有写RETURN，函数默认返回值是undefined3.函数体中遇到RETURN，后面代码则不再执行了 执行函数 实参 传递给形参变量的值（实参） arguments：函数内置的实参集合 1.类数组集合，集合中存储着所有函数执行时，传递的实参信息 2.不论是否设置形参，arguments都存在 3.不论是否传递实参，arguments也都存在arguments.callee：存储的是当前函数本身（一般不用的，JS严格模式下禁止使用这些属性） 函数底层运行机制 … 匿名函数匿名函数之函数表达式：把一个匿名函数本身作为值赋值给其它东西，这种函数一般不是手动触发执行，而且靠其它程序驱动触发执行（例如：触发某个事件的时候把它执行等）document.body.onclick = function () {}setTimeout(function(){},1000); //=&gt;设置定时器，1000MS后执行匿名函数 // 匿名函数之自调用：创建完一个匿名函数，紧接着就把当前函数加小括号执行// (function(n){// //n=&gt;100// })(100); 解决同步问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*========== 解决办法一：自定义属性解决办法 =========*/// 循环三个LI，给每一个LI都绑定点击事件for (var i = 0; i &lt; navList.length; i++) &#123; // navList[i] : 当前循环下我们要操作的那个LI（I变量存储的值是我们需要获取指定元素的索引） // 在循环给每个LI绑定点击事件的时候，我们给每一个LI（元素对象）设置一个自定义属性MY-INDEX，属性值存储的是当前LI的索引 navList[i].myIndex = i; navList[i].onclick = function () &#123; // 我想用的是点击这个LI的索引，但是I不是 // THIS是当前点击的这个元素LI;THIS.MY-INDEX获取的就是之前绑定在元素自定义属性上的索引值; changeTab(this.myIndex); &#125;&#125;/* ========其它方式========== */// 闭包解决方案/* for (var i = 0; i &lt; navList.length; i++) &#123; navList[i].onclick = (function (i) &#123; return function () &#123; changeTab(i); &#125; &#125;)(i);&#125; */// ES6中的LET解决方案/* for (let i = 0; i &lt; navList.length; i++) &#123; navList[i].onclick = function () &#123; changeTab(i); &#125;&#125; *///========================================不行的/* for (var i = 0; i &lt; navList.length; i++) &#123; navList[i].onclick = function () &#123; changeTab(i); &#125;&#125; *//* * 只有JS代码加载完成才能看到页面，只有看到页面用户才能点击 * 加载到循环这个代码了 i=0 i&lt;3 i++ * i=0 navList[0].onclick=function()&#123;...&#125; 绑定事件的时候方法没有执行，点击第一个LI的时候它才执行 i++ =&gt;1 * i=1 navList[1].onclick=function()&#123;...&#125; i++ =&gt;2 * i=2 navList[2].onclick=function()&#123;...&#125; i++ =&gt;3 * 3&lt;3 不同过，循环结束，此时i已经是3了 * * 循环结束看到了页面，用户去点击了某一个页卡，接下来开始执行绑定的方法，方法中遇到了一个I，但是此时I已经是循环结束后的3了 */// 封装一个函数实现选项卡的切换// clickIndex:创建函数的时候还不知道点的是谁，所以定义一个入口clickIndex（存储点击这一项的索引），执行方法的时候把点击这一项的索引传递进来即可function changeTab(clickIndex) &#123; // 1.先让所有的LI和DIV都没有选中的样式 for (var i = 0; i &lt; navList.length; i++) &#123; navList[i].className = ''; tabList[i].className = ''; &#125; // 2.点击的是谁就给谁加选中样式类 navList[clickIndex].className = 'active'; tabList[clickIndex].className = 'active';&#125; JS中内置对象一、Math 数学函数：但是它不是一个函数，它是一个对象，对象中存储了很多操作数字的属性方法，因此被称为数学函数 Math中常用的属性和方法 Math.abs([number value]) 获取绝对值（绝对值永远是正数或者零） 12345console.log(Math.abs(-12.5)); //=&gt;12.5console.log(Math.abs(12)); //=&gt;12// 传递的不是数字类型的值：先基于Number()转换为数字再处理console.log(Math.abs('-1px')); //=&gt;NaNconsole.log(Math.abs(true)); //=&gt;1 Math.ceil / floor([number value]) 把一个数向上取整 / 向下取整 Math.round() 四舍五入 1234console.log(Math.round(12.1)); //=&gt;12console.log(Math.round(12.5)); //=&gt;13 正数中.5属于入console.log(Math.round(-12.1)); //=&gt;-12console.log(Math.round(-12.5)); //=&gt;-12 负数中.5属于舍 Math.max / min ([val1],[val2],…) 获取一堆数中的最大值和最小值 1234console.log(Math.max(12, 5, 68, 23, 45, 3, 27)); //=&gt;68console.log(Math.min(12, 5, 68, 23, 45, 3, 27)); //=&gt;3//思考题：如何基于Math.max/min获取数组中的最大值最小值？Math.max([12, 5, 68, 23, 45, 3, 27]); //=&gt;NaN 此处是只传第一个值，是个数组，和内置的语法要求不符 Math.sqrt / pow() sqrt：给一个数开平方 pow：计算一个数的多少次幂 123console.log(Math.sqrt(9)); //=&gt;3 符合N*N=M 这样的M才能整开平方console.log(Math.sqrt(-9)); //=&gt;NaN 负数开不了平方console.log(Math.pow(2, 10)); //=&gt;1024 Math.random() 获取0~1之间的随机小数 扩展：获取 [n~m] 之间的随机整数 包含n也包含m n&lt;m 1Math.round(Math.random()*(m-n)+n) 数组及数组中常用的方法 数组是对象数据类型的，它属于特殊的对象 数组中常用的方法 方法的作用和含义 方法的实参（类型和含义） 方法的返回值 原来的数组是否会发生改变 1.实现数组增删改的方法 这一部分方法都会修改原有的数组 push 123456789101112/* * push : 向数组末尾增加内容 * @params * 多个任意类型 * @return * 新增后数组的长度 */let ary = [10, 20];let res = ary.push(30, 'AA');// 基于原生JS操作键值对的方法，也可以向末尾追加一项新的内容ary[ary.length] = 40;console.log(res, ary); //=&gt;4 [10,20,30,'AA',40] unshift 1234567891011121314/* * unshift : 向数组开始位置增加内容 * @params * 多个任意类型 * @return * 新增后数组的长度 */let ary = [10, 20];let res = ary.unshift(30, 'AA');console.log(res, ary); //=&gt;4 [30,'AA',10,20]// 基于原生ES6展开运算符，把原有的ARY克隆一份，在新的数组中创建第一项，其余的内容使用原始ARY中的信息即可，也算实现了向开始追加的效果ary = [100, ...ary];console.log(ary); //=&gt;[100,30,'AA',10,20] shift 12345678910111213/* * shift : 删除数组中的第一项 * @params * @return * 删除的那一项 */let ary = [10, 20, 30, 40];let res = ary.shift();console.log(res, ary); //=&gt;10 [20, 30, 40]// 基于原生JS中的DELETE，把数组当做普通的对象，确实可以删除掉某一项内容，但是不会影响数组本身的结构特点（length长度不会跟着修改）,真实项目中杜绝这样的删除使用delete ary[0];console.log(ary); //=&gt;&#123;1:30,2:40,length:3&#125; pop 12345678910111213/* * pop : 删除数组中的最后一项 * @params * @return * 删除的那一项 */let ary = [10, 20, 30, 40];let res = ary.pop();console.log(res, ary); //=&gt;40 [10,20,30]// 基于原生JS让数组数组长度干掉一位，默认干掉的就是最后一项ary.length--; //=&gt;ary.length = ary.length - 1;console.log(ary); splice 12345678910111213141516171819/* * splice : 实现数组的增加、删除、修改 * @params * n,m 都是数字 从索引n开始删除m个元素（m不写，是删除到末尾） * @return * 把删除的部分用新数组存储起来返回 */let ary = [10, 20, 30, 40, 50, 60, 70, 80, 90];let res = ary.splice(2, 4);console.log(res, ary); //=&gt;[30, 40, 50, 60] [10, 20, 70, 80, 90]// 基于这种方法可以清空一个数组，把原始数组中的内容以新数组存储起来（有点类似数组的克隆：把原来数组克隆一份一模一样的给新数组）/* res = ary.splice(0);console.log(res, ary);//=&gt;[10, 20, 70, 80, 90] [] */// 删除最后一项和第一项ary.splice(ary.length - 1);ary.splice(0, 1);console.log(ary); 123456789101112131415161718192021/* * splice : 实现数组的增加、修改 * @params * n,m,x 从索引n开始删除m个元素，用x占用删除的部分 * n,0,x 从索引n开始，一个都不删，把x放到索引n的前面 * @return * 把删除的部分用新数组存储起来返回 */let ary = [10, 20, 30, 40, 50];let res = ary.splice(1, 2, '珠峰培训', '哈哈哈');console.log(res, ary); //=&gt; [20,30] [10,'珠峰培训','哈哈哈', 40, 50]// 实现增加ary.splice(3, 0, '呵呵呵');console.log(ary); //=&gt;[10, \"珠峰培训\", \"哈哈哈\", \"呵呵呵\", 40, 50]// 向数组末尾追加ary.splice(ary.length, 0, 'AAA');// 向数组开始追加ary.splice(0, 0, 'BBB'); 2.数组的查询和拼接 此组学习的方法，原来数组不会改变 slice 1234567891011121314151617181920/* * slice : 实现数组的查询 * @params * n,m 都是数字 从索引n开始，找到索引为m的地方（不包含m这一项） * @return * 把找到的内容以一个新数组的形式返回 */let ary = [10, 20, 30, 40, 50];let res = ary.slice(1, 3);console.log(res); //=&gt;[20,30]// m不写是找到末尾res = ary.slice(1);console.log(res); //=&gt;[20, 30, 40, 50]// 数组的克隆，参数0不写也可以res = ary.slice(0);console.log(res); //=&gt;[10, 20, 30, 40, 50]// 思考：1.如果n/m为负数会咋地，如果n&gt;m了会咋地，如果是小数会咋地，如果是非有效数字会咋地，如果m或者n的值比最大索引都会咋地？ 2.这种克隆方式叫做浅克隆，可以回去先看看深度克隆如何处理! concat 1234567891011/* * concat : 实现数组拼接 * @params * 多个任意类型值 * @return * 拼接后的新数组（原来数组不变） */let ary1 = [10, 20, 30];let ary2 = [40, 50, 60];let res = ary1.concat('珠峰培训', ary2);console.log(res); 3.把数组转换为字符串 原有数组不变 toString 1234567891011/* * toString : 把数组转换为字符串 * @params * @return * 转换后的字符串，每一项用逗号分隔（原来数组不变） */let ary = [10, 20, 30];let res = ary.toString();console.log(res); //=&gt;\"10,20,30\"console.log([].toString()); //=&gt;\"\"console.log([12].toString()); //=&gt;\"12\" join 1234567891011121314151617181920/* * join : 把数组转换为字符串 * @params * 指定的分隔符（字符串格式） * @return * 转换后的字符串（原来数组不变） */let ary = [10, 20, 30];let res = ary.join('');console.log(res); //=&gt;\"102030\"res = ary.join();console.log(res); //=&gt;\"10,20,30\"res = ary.join('|');console.log(res); //=&gt;\"10|20|30\"res = ary.join('+');console.log(res); //=&gt;\"10+20+30\"console.log(eval(res)); //=&gt;60 eval把字符串变为JS表达式执行 4.检测数组中的是否包含某一项 indexOf / lastIndexOf / includes 1234567891011121314151617181920/* * indexOf / lastIndexOf : 检测当前项在数组中第一次或者最后一次出现位置的索引值（在IE6~8中不兼容） * @params * 要检索的这一项内容 * @return * 这一项出现的位置索引值（数字），如果数组中没有这一项，返回的结果是-1 * 原来数组不变 */let ary = [10, 20, 30, 10, 20, 30];console.log(ary.indexOf(20)); //=&gt;1console.log(ary.lastIndexOf(20)); //=&gt;4// 想验证ARY中是否包含'珠峰培训'if (ary.indexOf('珠峰培训') === -1) &#123; // 不包含&#125;// 也可以直接使用ES6新提供的includes方法判断if (ary.includes('珠峰培训')) &#123; // 包含：如果存在返回的是TRUE&#125; 5.数组的排序或者排列 reverse 12345678910/* * reverse : 把数组倒过来排列 * @params * @return * 排列后的新数组 * 原来数组改变 */let ary = [12, 15, 9, 28, 10, 22];ary.reverse();console.log(ary); //=&gt;[22, 10, 28, 9, 15, 12] sort 12345678910111213141516171819202122/* * sort : 实现数组的排序 * @params * 可以没有，也可以是个函数 * @return * 排序后的新数组 * 原来数组改变 */let ary = [7, 8, 5, 2, 4, 6, 9];ary.sort();console.log(ary); //=&gt;[2, 4, 5, 6, 7, 8, 9]// SORT方法中如果不传递参数，是无法处理10以上数字排序的(它默认按照每一项第一个字符来排，不是我们想要的效果)/* ary = [12, 15, 9, 28, 10, 22];ary.sort();console.log(ary); //=&gt; [10, 12, 15, 22, 28, 9] */// 想要实现多位数正常排序，需要给SORT传递一个函数，函数中返回 a-b 实现升序，返回 b-a 实现降序ary = [12, 15, 9, 28, 10, 22];// ary.sort(function(a,b)&#123; return a-b; &#125;);ary.sort((a, b) =&gt; a - b);console.log(ary); 6.遍历数组中每一项的方法 forEach 12345678910111213141516171819202122/* * forEach：遍历数组中的每一项内容 * @params * 回调函数 * @return * * 原来数组不变 */let ary = [12, 15, 9, 28, 10, 22];/* // 基于原生JS中的循环可以实现for (let i = 0; i &lt; ary.length; i++) &#123; // i:当前循环这一项的索引 // ary[i]:根据索引获取循环的这一项 console.log('索引：' + i + ' 内容：' + ary[i]);&#125; */ary.forEach((item, index) =&gt; &#123; // 数组中有多少项，函数就会被默认执行多少次 // 每一次执行函数：item是数组中当前要操作的这一项，index是当前项的索引 console.log('索引：' + index + ' 内容：' + item);&#125;); map 数组中的每一个元素执行这个函数，把执行的结果重新放在一个数组中返回 filter 数组中每一个元素都符合条件的元素组成一个新的数组返回 find reduce some every 如果数组中的每一个元素都满足条件的话 返回ture否则flase …… Array.prototype 在控制台查看数组中所有提供的方法，可以基于MDN网站去查询方法的用法 字符串中常用的方法 所有用 单引号、双引号、反引号 包起来的都是字符串 123456let str = 'zhufengpeixunyangfanqihang';// 每一个字符串都是由零到多个字符组成的str.length //=&gt;字符串长度str[0] //=&gt;获取索引为零（第一个）字符str[str.length-1] //=&gt;获取最后一个字符str.length-1最后一项索引str[10000] //=&gt;undefined 不存在这个索引 charAt / charCodeAt 12345678910111213141516/* * charAt：根据索引获取指定位置的字符 * charCodeAt：获取指定字符的ASCII码值（Unicode编码值） * @params * n [number] 获取字符指定的索引 * @return * 返回查找到的字符 * 找不到返回的是空字符串不是undefined，或者对应的编码值 */let str = 'zhufengpeixunyangfanqihang';console.log(str.charAt(0)); //=&gt;'z'console.log(str[0]); //=&gt;'z'console.log(str.charAt(10000)); //=&gt;''console.log(str[10000]); //=&gt;undefinedconsole.log(str.charCodeAt(0)); //=&gt;122console.log(String.fromCharCode(122)); //=&gt;'z' substr / substring / slice 12345678910111213141516/* * 都是为了实现字符串的截取（在原来字符串中查找到自己想要的） * substr(n,m)：从索引n开始截取m个字符，m不写截取到末尾（后面方法也是） * substring(n,m)：从索引n开始找到索引为m处(不含m) * slice(n,m)：和substring一样，都是找到索引为m处，但是slice可以支持负数作为索引，其余两个方法是不可以的 */let str = 'zhufengpeixunyangfanqihang';console.log(str.substr(3, 7)); //=&gt;'fengpei'console.log(str.substring(3, 7)); //=&gt;'feng'console.log(str.substr(3)); //=&gt;'fengpeixunyangfanqihang' 截取到末尾console.log(str.substring(3, 10000)); //=&gt;'fengpeixunyangfanqihang' 截取到末尾（超过索引的也只截取到末尾）console.log(str.substring(3, 7)); //=&gt;'feng'console.log(str.slice(3, 7)); //=&gt;'feng'console.log(str.substring(-7, -3)); //=&gt;'' substring不支持负数索引console.log(str.slice(-7, -3)); //=&gt;'nqih' slice支持负数索引 =&gt;快捷查找：负数索引，我们可以按照 STR.LENGTH+负索引 的方式找 =&gt;slice(26-7,26-3) =&gt;slice(19,23) indexOf / lastIndexof / includes 1234567891011121314151617181920212223/* * 验证字符是否存在 * indexOf(x,y)：获取x第一次出现位置的索引，y是控制查找的起始位置索引 * lastIndexOf(x)：最后一次出现位置的索引 * =&gt;没有这个字符，返回的结果是-1 */let str = 'zhufengpeixunyangfanqihang';console.log(str.indexOf('n')); //=&gt;5console.log(str.lastIndexOf('n')); //=&gt;24console.log(str.indexOf('@')); //=&gt;-1 不存在返回-1if (str.indexOf('@') === -1) &#123; // 字符串中不包含@这个字符&#125;console.log(str.indexOf('feng')); //=&gt;3 验证整体第一次出现的位置，返回的索引是第一个字符所在位置的索引值console.log(str.indexOf('peiy')); //=&gt;-1console.log(str.indexOf('n', 7)); //=&gt;12 查找字符串索引7及之后的字符串中，n第一次出现的位置索引 if (!str.includes('@')) &#123; console.log('当前字符串不包含@');&#125; toUpperCase / toLowerCase 12345678/* * 字符串中字母的大小写转换 * toUpperCase()：转大写 * toLowerCase()：转小写 */// 实现首字母大写str = str.substr(0, 1).toUpperCase() + str.substr(1);console.log(str); //=&gt;'Zhufengpeixunyangfanqihang' split 12345678910/* * split([分隔符]):把字符串按照指定的分隔符拆分成数组（和数组中join对应） * * split支持传递正则表达式 */// 需求：把|分隔符变为,分隔符let str = 'music|movie|eat|sport';let ary = str.split('|'); //=&gt;[\"music\", \"movie\", \"eat\", \"sport\"]str = ary.join(',');console.log(str); //=&gt;\"music,movie,eat,sport\" replace 123456789/* * replace(老字符,新字符)：实现字符串的替换（经常伴随着正则而用） */let str = '珠峰@培训@扬帆@起航';// str = str.replace('@', '-');// console.log(str); //=&gt;\"珠峰-培训@扬帆@起航\" 在不使用正则表达式的情况下，执行一次REPLACE只能替换一次字符str = str.replace(/@/g, '-');console.log(str); //=&gt;珠峰-培训-扬帆-起航 match localCompare trim / trimLeft / trimRight … 控制台输出 String.prototype 查看所有字符串中提供的方法 实现一些常用的需求 时间字符串的处理 1234567891011121314let time = '2019-7-24 12:6:23';//=&gt; 变为自己需要呈现的格式，例如：// \"2019年07月24日 12时06分23秒\"// \"2019年07月24日\"// \"07/24 12:06\"// ...//不足十位补零的方法let addZero = val =&gt; val.length &lt; 2 ? '0' + val : val;//处理方式let ary = time.split(/(?: |-|:)/g); //=&gt;[\"2019\", \"7\", \"24\", \"12\", \"6\", \"23\"]time = ary[0] + '年' + addZero(ary[1]) + '月' + addZero(ary[2]) + '日'; 实现一个方法 queryURLParameter 获取一个URL地址问号后面传递的参数信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * queryURLParams：获取URL地址中问号传参的信息和哈希值 * @params * url [string] 要解析的URL字符串 * @return * [object] 包含参数和哈希值信息的对象 * by zhouxiaotian on 2019/07/24 16:29:00 */function queryURLParams(url) &#123; //1.获取?和#后面的信息 let askIn = url.indexOf('?'), wellIn = url.indexOf('#'), askText = '', wellText = ''; // #不存在 wellIn === -1 ? wellIn = url.length : null; // ?存在 askIn &gt;= 0 ? askText = url.substring(askIn + 1, wellIn) : null; wellText = url.substring(wellIn + 1); //2.获取每一部分信息 let result = &#123;&#125;; wellText !== '' ? result['HASH'] = wellText : null; if (askText !== '') &#123; let ary = askText.split('&amp;'); ary.forEach(item =&gt; &#123; let itemAry = item.split('='); result[itemAry[0]] = itemAry[1]; &#125;); &#125; return result;&#125;/* //基于正则封装的才是最完美的function queryURLParams(url) &#123; let result = &#123;&#125;, reg1 = /([^?=&amp;#]+)=([^?=&amp;#]+)/g, reg2 = /#([^?=&amp;#]+)/g; url.replace(reg1, (n, x, y) =&gt; result[x] = y); url.replace(reg2, (n, x) =&gt; result['HASH'] = x); return result;&#125; */let aa = 'http://www.zhufengpeixun.cn/index.html?lx=1&amp;name=zhufeng&amp;teacher=aaa#box';let paramsObj = queryURLParams(aa);console.log(paramsObj); 实现一个最LOW的验证码：数字+字母共四位 验证码目的：防止外挂程序恶意批量注入的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;body&gt; &lt;input type=\"text\" id=\"codeInp\"&gt; &lt;br&gt; &lt;span id=\"codeBox\"&gt;AAAA&lt;/span&gt; &lt;button id=\"changeCode\"&gt;看不清换一张&lt;/button&gt; &lt;!-- IMPORT JS --&gt; &lt;script&gt; let codeInp = document.getElementById('codeInp'), codeBox = document.getElementById('codeBox'), changeCode = document.getElementById('changeCode'); /* * queryCode：获取到四位随机验证码，然后放到指定的盒子中 * @params * @return * by Team on 2019/07/24 */ function queryCode() &#123; // 准备获取范围的字符串 0~61 let area = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; let result = \"\"; for (let i = 0; i &lt; 4; i++) &#123; // 每一次循环都获取一个随机的数字索引 let ran = Math.round(Math.random() * 61); // 再根据获取的索引从范围字符串中找到对应的字符，把找到的字符拼接到最后的结果中 result += area.charAt(ran); &#125; // 放到盒子里面 codeBox.innerHTML = result; &#125; // 第一次加载页面需要执行方法，让其显示在页面中 queryCode(); // 点击看不清按钮，需要重新执行方法生成新的验证码 changeCode.onclick = queryCode; // 文本框失去焦点的时候：验证用户输入的内容和验证码是否相同，给予相关的提示，如果不一样需要重新生成验证码 // onblur：文本框失去焦点事件 codeInp.onblur = function () &#123; // 获取用户和验证码内容（表单元素.value / 非标单元素.innerHTML 获取内容） let val = codeInp.value, code = codeBox.innerHTML; // 不区分大小写的验证（都转成小写） if (val.toLowerCase() === code.toLowerCase()) &#123; alert('温馨提示：验证码输入成功！'); &#125; else &#123; alert('温馨提示：验证码输入有误，请重试！'); codeInp.value = ''; // 重新生成验证码 queryCode(); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 日期对象的基本操作123456789let time = new Date();/* * 获取当前客户端（本机电脑）本地的时间 * 这个时间用户是可以自己修改的，所以不能作为重要的参考依据 * * Fri Jul 26 2019 10:02:17 GMT+0800 (中国标准时间) * 获取的结果不是字符串是对象数据类型的，属于日期对象(或者说是Date这个类的实例对象) */typeof time; //=&gt;\"object\" 标准日期对象中提供了一些属性和方法，供我们操作日期信息 getFullYear() 获取年 getMonth() 获取月 结果是0~11代表第一月到第十二月 getDate() 获取日 getDay() 获取星期 结果是0~6代表周日到周六 getHours() 获取时 getMinutes() 获取分 getSeconds() 获取秒 getMilliseconds() 获取毫秒 getTime() 获取当前日期距离1970/1/1 00:00:00 这个日期之间的毫秒差 toLocaleDateString() 获取年月日（字符串） toLocaleString() 获取完整的日期字符串 new Date() 除了获取本机时间，还可以把一个时间格式字符串转换为标准的时间格式 123456789new Date(\"2019/7/26\");//=&gt;Fri Jul 26 2019 00:00:00 GMT+0800 (中国标准时间)/* * 支持的格式 * yyyy/mm/dd * yyyy/mm/dd hh:mm:ss * yyyy-mm-dd 这种格式在IE下不支持 */ 时间字符串格式化案例 字符串处理解决办法 123456789101112131415161718192021222324// =&gt;不足十位补充零let addZero = val =&gt; &#123; val = Number(val); return val &lt; 10 ? '0' + val : val;&#125;;/** 字符串处理解决办法*/function formatTime(time) &#123; // 1.先获取年月日等信息 let ary = time.split(' '), aryLeft = ary[0].split('-'), aryRight = ary[1].split(':'); ary = aryLeft.concat(aryRight); // 2.拼接成为我们想用的格式 let result = ary[0] + \"年\" + addZero(ary[1]) + \"月\" + addZero(ary[2]) + \"日\"; result += \" \" + addZero(ary[3]) + \":\" + addZero(ary[4]) + \":\" + addZero(ary[5]); return result;&#125;let time = '2019-5-30 12:0:0'; time = formatTime(time);console.log(time);// =&gt;\"2019年05月30日 12:00:00\" 基于日期对象处理 123456789101112131415161718192021/* * 基于日期对象处理 */function formatTime(time) &#123; // 1.把时间字符串变为标准日期对象 time = time.replace(/-/g, '/'); time = new Date(time); // 2.基于方法获取年月日等信息 let year = time.getFullYear(), month = addZero(time.getMonth() + 1), day = addZero(time.getDate()), hours = addZero(time.getHours()), minutes = addZero(time.getMinutes()), seconds = addZero(time.getSeconds()); // 3.返回想要的结果 return year + \"年\" + month + \"月\" + day + \"日 \" + hours + \":\" + minutes + \":\" + seconds;&#125;let time = '2019-5-30 12:0:0';time = formatTime(time);console.log(time);// =&gt;\"2019年05月30日 12:00:00\" 封装一套公共的时间字符串格式化处理的方式 1234567891011121314151617181920/* * 封装一套公共的时间字符串格式化处理的方式 */String.prototype.formatTime = function formatTime(template) &#123; // 初始化模板 typeof template === 'undefined' ? template = \"&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;:&#123;4&#125;:&#123;5&#125;\" : null; // this:我们要处理的字符串 // 获取日期字符串中的数字信息 let matchAry = this.match(/\\d+/g); // 模板和数据的渲染（引擎机制） template = template.replace(/\\&#123;(\\d+)\\&#125;/g, (x, y) =&gt; &#123; let val = matchAry[y] || '00'; val.length &lt; 2 ? val = '0' + val : null; return val; &#125;); return template;&#125;;let time = '2019-5-30 12:0:0';console.log(time.formatTime(\"&#123;1&#125;-&#123;2&#125; &#123;3&#125;:&#123;4&#125;\"));// =&gt;\"2019年05月30日 12:00:00\" DOM及其基础操作 DOM：document object model 文档对象模型，提供一些属性和方法供我们操作页面中的元素 获取DOM元素的方法 document.getElementById() 指定在文档中，基于元素的ID或者这个元素对象 [context].getElementsByTagName() 在指定上下文(容器)中，通过标签名获取一组元素集合 [context].getElementsByClassName() 在指定上下文中，通过样式类名获取一组元素集合 （不兼容IE6~8） document.getElementsByName() 在整个文档中，通过标签的NAME属性值获取一组节点集合 （在IE中只有表单元素的NAME才能识别，所以我们一般只应用于表单元素的处理） document.head / document.body / document.documentElement 获取页面中的 HEAD/BODY/HTML 三个元素 [context].querySelector([selector]) 在指定上下文中，通过选择器获取到指定的元素对象 [context].querySelectorAll([selector]) 在指定上下文中，通过选择器获取到指定的元素集合 12345//=&gt; querySelector / querySelectorAll 不兼容IE6~8let box = document.querySelector('#box');let links = box.querySelectorAll('a');// links=document.querySelectorAll('#box a');let aas=document.querySelectorAll('.aa'); JS中的节点和描述节点之间关系的属性 节点 ： Node （页面中所有的东西都是节点） 节点集合：NodeList （getElementsByName / querySelectorAll 获取的都是节点集合） 元素节点 （元素标签） nodeType：1 nodeName : 大写的标签名 nodeValue ：null 文本节点 nodeType：3 nodeName : ‘#text’ nodeValue ：文本内容 注释节点 nodeType：8 nodeName : ‘#commen’ nodeValue ：注释内容 文档节点 document nodeType：9 nodeName : ‘#document’ nodeValue ：null …… 描述这些节点之家关系的属性 childNodes ：获取所有的子节点 children：获取所有的元素子节点（子元素标签集合） parent：获取父亲节点 firstChild：获取第一个子节点 lastChild：获取最后一个子节点 firstElementChild / lastElementChild ：获取第一个和最后一个元素子节点 （不兼容IE6~8） previousSibling：获取上一个哥哥节点 nextSibling：获取下一个弟弟节点 previousElementSibling / nextElementSibling ：获取哥哥和弟弟元素节点（不兼容IE6~8） …… 在JS中动态增删改元素createElement 创建元素对象 createTextNode 创建文本对象 appendChild 把元素添加到容器的末尾 insertBefore 把元素添加到指定容器中指定元素的前面 123456789101112131415161718// 动态创建一个DIV元素对象，把其赋给BOXlet box = document.createElement('div');box.id = 'boxActive';box.style.width = '200px';box.style.height = '200px';box.className = 'RED';// 动态创建一个文本let text = document.createTextNode('珠峰培训');// 添加：容器.appendChild(元素)box.appendChild(text);// document.body.appendChild(box);// 放到指定元素前：容器.insertBefore([新增元素],[指定元素])let haha = document.getElementById('haha');// haha.parentNode.insertBefore(...)document.body.insertBefore(box, haha); cloneNode(true/false) 克隆元素或者节点 removeChild 移除容器中的某个元素 12345678910111213141516171819&lt;div class=\"box\"&gt; &lt;span&gt;珠峰培训1&lt;/span&gt;&lt;/div&gt;&lt;script&gt; let box1 = document.querySelector('.box'); // 克隆第一份（深克隆） let box2 = box1.cloneNode(true); box2.querySelector('span').innerText = '珠峰培训2'; // 克隆第二份（浅克隆） let box3 = box1.cloneNode(false); box3.innerHTML = \"&lt;span&gt;珠峰培训3&lt;/span&gt;\"; document.body.appendChild(box2); document.body.appendChild(box3); //=========== // 容器.removeChild(元素) document.body.removeChild(box2);&lt;/script&gt; setAttribute / getAttribute / removeAttribute 设置获取移除元素的自定义属性信息（这种方式是把自定义属性放到元素结构上） 123456789101112131415var btnList = document.querySelectorAll('button');for (var i = 0; i &lt; btnList.length; i++) &#123; // 设置自定义属性：元素对象.属性名=属性值（原理是向元素对象对应的堆内存中添加了一个属性） // btnList[i].myIndex = i; // 设置自定义属性：基于SET-ATTRIBUTE是把属性信息写到了元素标签的结构上（在结构中可以看到的），并没有放到元素对象对应的堆内存中 btnList[i].setAttribute('data-index', i); btnList[i].onclick = function () &#123; // 获取自定义属性：元素对象.属性名 （原理是从堆内存中获取到对应的属性值） // alert(this.myIndex); // 基于GET-ATTRIBUTE可以把结构上存储的自定义属性值获取 alert(this.getAttribute('data-index')); &#125;&#125;","categories":[],"tags":[{"name":"JS javascript 总结","slug":"JS-javascript-总结","permalink":"http://yoursite.com/tags/JS-javascript-总结/"}]},{"title":"ES6复习及学习","slug":"ES6复习及学习","date":"2019-09-30T02:48:31.000Z","updated":"2019-10-13T02:52:16.607Z","comments":true,"path":"2019/09/30/ES6复习及学习/","link":"","permalink":"http://yoursite.com/2019/09/30/ES6复习及学习/","excerpt":"","text":"","categories":[],"tags":[{"name":"ES6 javascript","slug":"ES6-javascript","permalink":"http://yoursite.com/tags/ES6-javascript/"}]},{"title":"Vue的复习及一个新的项目练手","slug":"Vue的复习及一个新的项目练手","date":"2019-09-18T13:57:05.000Z","updated":"2019-11-07T10:46:25.591Z","comments":true,"path":"2019/09/18/Vue的复习及一个新的项目练手/","link":"","permalink":"http://yoursite.com/2019/09/18/Vue的复习及一个新的项目练手/","excerpt":"vue框架的学习","text":"vue框架的学习 创造一个vue实例123456789var app = new Vue(&#123; el:'#app', data:&#123;//用于存储数据的 &#125;, methods:&#123;//用于定义事件的 &#125;, components:&#123;//用来注册局部组件 &#125;&#125;) VUE的指令1. v-on： 用于绑定事件的（简写@：）12 2. v-model指令可以实现表单元素和model中的数据的双向绑定（只能用于表单元素） 3. v-bind: 用于绑定属性的指令（简写 ：）[单向绑定]4. v-html 插入一个HTML，v-text插入文本字符串，该方法没有闪烁问题，而使用插值表达式存在闪烁问题（v-text会覆盖元素中原来的内容，但插值表达式只会替换）v-if 和 v-show指令都是用于条件性地渲染一块内容。不同的是：v-if特点：每次都会重新删除或创建元素，有着较高的切换性能消耗。v-show特点：每次不会重新进行DOM的删除和创建操作，只是切换了元素的display：none的样式。有着较高的初始渲染消耗。v-if可以和v-else,v-else-if一起使用 定义vue组件1.使用Vue.component（’组件名称’,创建出来的组件模板对象） Vue.extend({template:模板结构})若Vue.component定义时使用了驼峰命名法，则使用组件用标签形式时，需将大写改小写中间加-2.使用字面量创建Vue.compnent(“名称”,{template:”模板结构”})，使用templeta标签引用不管使用那种方式创建出的组件，组件中的template内容有且只有一个根元素组件中有自己的date和methods数据，组件中的date必须是个方法，且这个方法内部必须返回一个对象才行 vue实现TodoList:MVVM模式v-model作用:input里面的value值和vue实例中的inputValue进行了双向的数据绑定 &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&apos;inputValue&apos;&gt; &lt;button v-on:click=&apos;handleBtnClick&apos;&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&apos;item in list&apos;&gt; &lt;/li&gt; &lt;/ul&gt; /div&gt; var app = new Vue({ el : &apos;#app&apos;, data : { list : [], inputValue:&apos;&apos; }, methods:{ handleBtnClick:function(){ this.list.push(this.inputValue) this.inputValue=&apos;&apos; } } })前端组件化：全局组件和局部组件全局组件 // 全局组件，名称叫做TodoItem，内容是li标签 // 使用的时候，TodoItem 等价于 todo-item 来使用 Vue.component(&apos;TodoItem&apos;,{ template:&apos;&lt;li&gt;hello world&lt;/li&gt;&apos; })局部组件 // 局部组件,不能直接使用，需要注册到下面的应用实例里面 var TodoItem = { template:&apos;&lt;li&gt;hello world&lt;/li&gt;&apos;, } } //在vue实例中注册conponent var app = new Vue({ el : &apos;#app&apos;, components:{ TodoItem:TodoItem }})前端组件化：简单的组件间传值实现todolist的简单功能，单击添加的内容，进行删除 子组件向父组件传值：在子组件的模板template中添加监听事件 v-on/@，同时在子组件中定义绑定的事件子组件中的数据是由v-bind绑定的父组件中的data决定的，所以需要子组件绑定向外触发的事件，改变父组件中的值$emit()父组件向子组件传值：v-bind/:方式进行数据传递，同时子组件props要进行接收 &lt;hr style=&quot;visibility: hidden;&quot;&gt; &lt;ul class=&quot;pager&quot;&gt; &lt;li class=&quot;previous&quot;&gt; &lt;a href=&quot;/2019/06/21/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;内置对象和基本包装类型&quot;&gt; Previous&lt;br&gt; &lt;span&gt;内置对象和基本包装类型&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;next&quot;&gt; &lt;a href=&quot;/2019/06/25/Vue2.0%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;Vue2.0官方文档 知识点总结1&quot;&gt; Next&lt;br&gt; &lt;span&gt;Vue2.0官方文档 知识点总结1&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!--Gitalk评论start --&gt; &lt;!-- Gitalk end --&gt; &lt;/div&gt; &lt;!-- Side Catalog Container --&gt; &lt;div class=&quot; col-lg-2 col-lg-offset-0 visible-lg-block sidebar-container catalog-container&quot;&gt; &lt;div class=&quot;side-catalog&quot;&gt; &lt;hr class=&quot;hidden-sm hidden-xs&quot;&gt; &lt;h5&gt; &lt;a class=&quot;catalog-toggle&quot; href=&quot;#&quot;&gt;CATALOG&lt;/a&gt; &lt;/h5&gt; &lt;ul class=&quot;catalog-body&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Sidebar Container --&gt; &lt;div class=&quot; col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container&quot;&gt; &lt;!-- Featured Tags --&gt; &lt;section&gt; &lt;hr class=&quot;hidden-sm hidden-xs&quot;&gt; &lt;h5&gt;&lt;a href=&quot;/tags/&quot;&gt;FEATURED TAGS&lt;/a&gt;&lt;/h5&gt; &lt;div class=&quot;tags&quot;&gt; &lt;a href=&quot;/tags/#《JavaScript高级程序设计》&quot; title=&quot;《JavaScript高级程序设计》&quot; rel=&quot;6&quot;&gt; 《JavaScript高级程序设计》 &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 黑马视频 &gt;知识点&quot; title=&quot;&lt; 黑马视频 &gt;知识点&quot; rel=&quot;10&quot;&gt; &lt; 黑马视频 &gt;知识点 &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; Vue2.0官方文档 &gt; 知识点&quot; title=&quot;&lt; Vue2.0官方文档 &gt; 知识点&quot; rel=&quot;2&quot;&gt; &lt; Vue2.0官方文档 &gt; 知识点 &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 面试题整理 &gt;&quot; title=&quot;&lt; 面试题整理 &gt;&quot; rel=&quot;6&quot;&gt; &lt; 面试题整理 &gt; &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 算法题 &gt;&quot; title=&quot;&lt; 算法题 &gt;&quot; rel=&quot;2&quot;&gt; &lt; 算法题 &gt; &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 工作遇到的问题记录 &gt;&quot; title=&quot;&lt; 工作遇到的问题记录 &gt;&quot; rel=&quot;11&quot;&gt; &lt; 工作遇到的问题记录 &gt; &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 微信小程序的学习 &gt;&quot; title=&quot;&lt; 微信小程序的学习 &gt;&quot; rel=&quot;2&quot;&gt; &lt; 微信小程序的学习 &gt; &lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;!-- Friends Blog --&gt; &lt;hr&gt; &lt;h5&gt;FRIENDS&lt;/h5&gt; &lt;ul class=&quot;list-inline&quot;&gt; &lt;li&gt;&lt;a href=&quot;https://juejin.im/&quot;&gt;掘金&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/&quot;&gt;SegmentFault&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.v2ex.com/&quot;&gt;V2EX&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://readhub.cn/&quot;&gt;Readhub&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/&quot;&gt;OSCHINA&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://toutiao.io/posts/hot/7&quot;&gt;开发者头条&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; methods:{ //定义点击的时候向外触发一个delete事件，同时传入数组下标 handleItemClick:function(){ this.$emit(&apos;delete&apos;,this.index)//向外触发一个事件 } } } var app = new Vue({ //定义这个Vue实例场控的范围 el : &apos;#app&apos;, // 局部变量声明之后要在父组件中添加声明，才能使用 components:{ TodoItem:TodoItem }, data : { list : [], inputValue:&apos;&apos; }, methods:{ //定义的是绑定在input上面的点击事件，每提交一次都会触发在list中添加用户输入的内容，添加过后清空输入框，使用的是v-model这个进行数据的双向绑定 handleBtnClick:function(){ this.list.push(this.inputValue) this.inputValue=&apos;&apos; }, handleItemDelete:function(index){ this.list.splice(index,1) } } })vue实例的生命周期Vue的生命周期就是Vue实例在某一个时间点会自动执行的函数 Vue的生命周期函数并不会放在methods里面进行定义，而是直接放在实例对象里面就可以了 var vm = new Vue({ el:&apos;#app&apos;, data:{ test:&apos;hello world&apos; }, template:&apos;&lt;div&gt; &lt;/div&gt;&apos;, beforeCreate:function(){ console.log(&apos;beforeCreate&apos;) }, created:function(){ console.log(&apos;created&apos;) }, beforeMount:function(){//渲染前 console.log(this.$el);//没有输出内容 console.log(&apos;beforeMount&apos;); }, mounted:function(){//渲染后 console.log(this.$el); //可以输出&lt;div&gt;&apos;hello world&apos;&lt;/div&gt; console.log(&apos;mounted&apos;); }, beforeDestroy:function(){ console.log(&apos;beforeDestroy&apos;) }, destroyed:function(){ console.log(&apos;destroy&apos;) }, //数据改变之前 beforeUpdate:function(){ console.log(&apos;beforeUpate&apos;) }, //数据改变渲染之后 updated:function(){ console.log(&apos;updated&apos;) } })vue的模板语法第一种：插值表达式 ``；第二种： v-text 将标签中innerTxet的内容变成表达式代表的data中的内容，若有标签，会进行转义后输出；第三种 ： v-html 除了可以正常显示内容以外，遇到标签还会进行解析 。还有很多，例如v-on/@、v-bind/:等 &lt;div v-text=&apos;name + &quot;Lee&quot;&apos;&gt;&lt;/div&gt; &lt;div v-html=&apos;name + &quot;Lee&quot;&apos;&gt;&lt;/div&gt;当vue指令后面跟了一个值的时候，说明后面跟的不是字符串而是一个js的表达式 总结：这三种有什么不同呢? 共同点：都可以添加写js表达式”Lee”；区别：插值表达式和v-text功能是一样的，不会解析标签；v-html是可以解析标签的注意，当vue指令后面跟了一个值的时候，这个值就不再是字符串了 ，而是一个js表达式； 计算属性和侦听器第一种方法：计算属性computed特点：内置缓存，计算属性依赖的值不变化，它就不会重新计算； 当依赖的值发生了变化，就会重新计算一次； var vm = new Vue({ el: “#app”, data: { firstName: ‘Dell’, lastName: ‘Alice’, fullName: “Dell Alice”, age: 39 }, computed: { fullName: function () { console.log(‘computed’); return this.firstName + “ “ + this.lastName } }})第二种：方法methods，不如计算属性好缺点： 没有缓存机制，如果改变了页面中别的值，页面重新渲染一次，这个方法就执行一次； 在DOM结构中使用methods方法，要在方法后面加括号进行调用； new Vue({ el: “#app”, data: { firstName: ‘Dell’, lastName: ‘Alice’, fullName: “Dell Alice”, age: 39 }, methods:{第三种：侦听器watch特点：和计算属性很类似，会有缓存，依赖的变量不发生改变就不会重新计算；watch 和 computed 语法对比，功能相似，但是computed的语法更加简单； var vm = new Vue({ el: “#app”, data: { firstName: ‘Dell’, lastName: ‘Alice’, fullName: “Dell Alice”, age: 39 }, watch: { firstName: function () { console.log(‘计算了一次’); this.fullName = this.firstName + “ “ + this.lastName; }, lastName: function () { console.log(‘计算了一次’); this.fullName = this.firstName + “ “ + this.lastName; } }})计算属性的setter和getter取输入的值的时候，运行get方法；当设置值的时候，set执行。 var vm = new Vue({ el:&apos;#app&apos;, data:{ firstName:&apos;Dell&apos;, lastName:&apos;Alice&apos; }, // computed的特性是当它依赖的值变化的时候会进行重新计算 computed :{ fullName:{ get : function() { return this.firstName + &apos; &apos; + this.lastName // 写的时候不要漏写return以及this }, set : function(value){ //value参数可以获取到外部数据 var arr = value.split(&quot; &quot;); this.firstName = arr[0]; this.lastName = arr[1]; } } } })样式绑定第一种方法：class 的对象绑定方式:class=”{activated:isActivated} .activated {color: red;} &lt;div @click=’handleDivClick’ :class=”{activated:isActivated}”&gt; hello world var vm = new Vue({ el: “#app”, data: { isActivated: false }, // 第一种方法：class的对象绑定,绑定点击事件,事件改变class是否显示 methods: { handleDivClick: function () { this.isActivated = !this.isActivated; } } })第二种方法：class的数组绑定:class=”[activated,activatedOne]”class可以和一个数组绑定，数组里面写的内容代表的是一个变量；*class绑定的是数组里面的内容：class:”[activated]”显示的是activated中的内容 *。 &lt;div @click=’handleDivClick’ :class=”[activated,activatedOne]”&gt; hello world var vm = new Vue({ el: “#app1”, data: { activated: ‘’,//默认为空 activatedOne: ‘activated-one’ }, methods: { handleDivClick: function () { //如果class有样式属性,那么赋值为‘’空;如果没有,就给这个标签样式属性 this.activated = this.activated === &quot;activated&quot; ? &apos;&apos; : &quot;activated&quot; } } })第三种方法：内联样式 style1.对象绑定方式 :style=’styleObj’ &lt;div :style=’styleObj’ @click=’handleDivClick’&gt; hello world var vm = new Vue({ el: ‘#app2’, data: { styleObj: { color: ‘black’ } }, methods: { handleDivClick: function () { this.styleObj.color = this.styleObj.color === “black” ? ‘red’ : “black”; } }}) 2.数组绑定方式 :style=’[styleObj,{fontSize:”20px”}]’ hello world var vm = new Vue({ el: '#app3', data: { styleObj: { color: 'black' } }, methods: { handleDivClick: function () { this.styleObj.color = this.styleObj.color === 'black' ? \"red\" : 'black' } } }) 注意：写内联样式的时候，不要写font-size，要写fontSize 条件渲染 v-if v-show通过一个 v-if 和 v-show 的指令,结合js的表达式,决定一个标签是否在页面上展示； var vm = new Vue({ el:&apos;#app1&apos;, data:{ show:false, message:&apos;Hello World&apos; } })比较v-if和v-show 共同点：两者都可以控制一个模板标签是否在页面上显示； 不同点：v-if定义的标签，只要值是false，就不会存在于DOM结构之上； ​ v-show定义的标签值是false的时候,仍存在DOM上,只是display:none了； 在具体使用的时候,会更多用到v-show，不会频繁操作DOM树,性能相对高一些 。 条件表达式更加复杂的用法使用v-if和v-else的时候，要紧贴在一起使用，若中间有别的标签，那么页面就会报错，就无法解析。 &lt;div id=&quot;app2&quot;&gt; &lt;div v-if=&apos;show&apos;&gt;&lt;/div&gt; &lt;div v-else&gt;Bye World&lt;/div&gt; &lt;div v-if=&apos;show1 === &quot;a&quot;&apos;&gt;This is A&lt;/div&gt; &lt;div v-else-if=&apos;show1 ===&quot;b&quot; &apos;&gt;This is B&lt;/div&gt; &lt;div v-else&gt;This is others &lt;/div&gt; &lt;/div&gt; var vm = new Vue({ el:&apos;#app2&apos;, data:{ show1:&apos;a&apos;, show:false, message:&apos;hello world&apos; } })条件渲染中key值的使用为什么要使用key值：因为在改变show后,页面进行重新渲染时,会尽量复用页面上的DOM，导致已经输入的用户名的input没有清空并继续作为邮箱的input使用；为某个标签添加key值(名字任意)之后，Vue会知道是页面唯一的元素，两个key值不一样， Vue就不会尝试复用这个标签。 &lt;div id=&quot;app3&quot;&gt; &lt;div v-if=&apos;show2&apos; &gt; 用户名&lt;input key=&apos;username&apos;/&gt; &lt;/div&gt; &lt;div v-else&gt; 邮箱&lt;input key=&apos;passwaord&apos; /&gt; &lt;/div&gt; &lt;/div&gt; var vm =new Vue({ el:&apos;#app3&apos;, data:{ show3:false, } })列表渲染part1：数组循环 为了提升循环显示的性能，会给每个循环项上加一个唯一的key值， 这里不是很推荐写inedx值，会频繁造作DOM元素相对应的数据，废性能,可能会导致Vue没有办法充分复用节点，一般项目中除了内容还会返回id，使用这个id作为标识`:key=’item.id’ 当我们为数组增加内容的时候，不能使用数组的下标形式添加/改变数组 ( 这种方法虽然会改变数据，但是页面不会响应 ) 第一种响应式改变数组数据的方法：我们只能通过vue提供的7个数组变异方法来操作数组，才能够实现数据发生变化，页面也跟着变化这种响应式的方法：push增加最后一项、pop删除最后一项、shift删除第一项 、unshift添加第一项、 splice(1开始下标,1个数,添加的内容)数组的截取 、sort数组排序、 reverse数组取反； 第二种响应式改变数组数据的方法：改变数组内容并响应的方法，就是“改变引用”，直接修改引用的list，让它指向另一个数组的地址 第三种set方法：第二个参数代表了数组的下标，第三个是改变的内容 Vue.set方法[全局方法]：Vue.set（vm.userInfo , 2 , “beijing”） vm.$set方法[实力方法]：vm.$set（vm.userInfo , 2, “beijing”） 当我们要遍历两个标签，但是又不想用div标签来包裹这两个标签循环的时候，可以使用template模板占位符，在渲染的过程中并不会真正得被渲染到页面上 part2：除了数组，对象也可以进行循环 item是键值,key是键名,index是索引这里直接修改键值，页面是可以做到响应的，但是如果是添加一个键值对，就会发现只改变了数值，页面没有进行响应式改变；这个时候使用改变指向，直接重新赋值userInfo这个对象的所有值。 var vm = new Vue({ el:&apos;#app1&apos;, data:{ userInfo:{ name:&apos;Alice&apos;, age:28, gender:&apos;female&apos;, salary:&apos;zero&apos; } } })is属性解决模板标签的bug情况h5的规范里面，table里面一定要有tdoby，tbody里面一定要有tr，如果用row组件代替tr使用就会报错，同理还有里面都要放&lt;子组件中data的定义要用返回函数data在根组件里面可以直接定义，但是在子组件中定义data时，要求必须是一个函数，返回所对应的数据内容。 原因：子组件会被调用很多次，每一个子组件的数据之间最好没有冲突，每个子组件都有自己的数据；通过函数返回一个数据对象的目的，就是为了让每个子组件都拥有一个独立的数据存储，不会出现多个子组件之间互相影响的情况。 Vue.component(‘row’, { template: ‘&lt; &lt;ul class=&quot;pager&quot;&gt; &lt;li class=&quot;previous&quot;&gt; &lt;a href=&quot;/2019/06/21/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;内置对象和基本包装类型&quot;&gt; Previous&lt;br&gt; &lt;span&gt;内置对象和基本包装类型&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;next&quot;&gt; &lt;a href=&quot;/2019/06/25/Vue2.0%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;Vue2.0官方文档 知识点总结1&quot;&gt; Next&lt;br&gt; &lt;span&gt;Vue2.0官方文档 知识点总结1&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!--Gitalk评论start --&gt; &lt;!-- Gitalk end --&gt; &lt;/div&gt; &lt;!-- Side Catalog Container --&gt; &lt;div class=&quot; col-lg-2 col-lg-offset-0 visible-lg-block sidebar-container catalog-container&quot;&gt; &lt;div class=&quot;side-catalog&quot;&gt; &lt;hr class=&quot;hidden-sm hidden-xs&quot;&gt; &lt;h5&gt; &lt;a class=&quot;catalog-toggle&quot; href=&quot;#&quot;&gt;CATALOG&lt;/a&gt; &lt;/h5&gt; &lt;ul class=&quot;catalog-body&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Sidebar Container --&gt; &lt;div class=&quot; col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container&quot;&gt; &lt;!-- Featured Tags --&gt; &lt;section&gt; &lt;hr class=&quot;hidden-sm hidden-xs&quot;&gt; &lt;h5&gt;&lt;a href=&quot;/tags/&quot;&gt;FEATURED TAGS&lt;/a&gt;&lt;/h5&gt; &lt;div class=&quot;tags&quot;&gt; &lt;/div&gt; &lt;/section&gt;&lt;Vue之中如何操作DOM:ref用ref进行引用命名，$refs是所有引用的名称，找到我们定义的 ‘ hello ’ 的ref，获取其中的内容。 在标签上面使用ref通过this.$refs.名字 获取到的是标签对应的DOM元素this.$refs.hello.innerHTML 在组件上面使用ref通过this.$refs.名字 获取到的是子组件的引用this.$refs.counter1.number &lt;div ref=&apos;hello&apos; @click=&apos;handleDivClick&apos; &gt; hello world &lt;/div&gt; var vm = new Vue({ el: &apos;#root&apos;, methods: { handleDivClick: function () { alert(this.$refs.hello.innerHTML)//获取到DOM元素中的内容 } } })案例：计数器 &lt;div id=&apos;root1&apos;&gt; &lt;counter ref=&apos;counter1&apos; @change=&apos;handleChange&apos;&gt;&lt;/counter&gt; &lt;counter ref=&apos;counter2&apos; @change=&apos;handleChange&apos;&gt;&lt;/counter&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; Vue.component(&apos;counter&apos;,{ template:&apos;&lt;div @click=&quot;handleClick&quot;&gt;&lt;/div&gt;&apos;, data:function(){ return{ number:0 } }, methods:{ handleClick:function(){ this.number++ // 这里涉及到子组件向父组件传值的内容,用emit触发一个change事件,在父组件进行监听 this.$emit(&apos;change&apos;) } } }) var vm = new Vue({ el:&apos;#root1&apos;, data:{ total:0 }, methods:{ handleChange:function(){ this.total=this.$refs.counter1.number + this.$refs.counter2.number } } })父子组件传值父组件怎么向子组件传递数据：通过属性 父组件向子组件通过属性绑定传递值，子组件用props属性接收 ； count前面不加冒号，传递的是字符串；加了冒号传递的是js表达式，这里就是数字。 &lt;div id=&quot;root&quot;&gt; &lt;counter :count=&apos;2&apos; &gt;&lt;/counter&gt; &lt;counter :count=&apos;3&apos; &gt;&lt;/counter&gt; &lt;/div&gt; var counter={ props:[&apos;count&apos;], template:&apos;&lt;div&gt;0&lt;/div&gt;&apos; } var vm = new Vue ({ el : &apos;#root&apos;, data:{} })​ 在vue中有一个单向数据流的概念，父组件可以随意向子组件传递参数，但是子组件不可以修改父组件传递过来的参数，原因是因为父组件传递过来的数据是对象的时候，可能有多个子组件调用，若是子组件可以直接修改的话，就会影响到其他子组件。 ​ 如果直接写this.count++的话，会出现一个警告，提示不要直接修改父组件传过来的数据，所以在此，定义data里面的number作为count的副本，然后修改number的值。 var counter={ //子组件 props:[&apos;count&apos;], data:function(){ return { number:this.count } }, template:&apos;&lt;div @click=&quot;handleClick&quot;&gt;&lt;/div&gt;&apos;, methods:{ handleClick:function(){ this.number = this.number + 2; } } } var vm = new Vue ({ //根组件 el : &apos;#root&apos;, data:{ total:5 }, components:{ counter:counter } })子组件怎么向父组件传递数据: 通过事件this.$emit(‘increase’,2);这里向外触发一个increase事件，同时可以传递参数每次改变都加步长2，step； 让父组件监听，在根组件中添加监听事件handleIncrease事件，传入步长2。 组件的参数校验与非props特性​ 如果要实现子组件要求父组件传递过来的参数一定要是字符串，在props里面不写数组，而是写对象，对象的键就是我们接收的参数的名字。 &lt;div id=&quot;root&quot;&gt; &lt;child content=&apos;hello world&apos;&gt;&lt;/child&gt; &lt;/div&gt;//子组件Vue.component(‘child’,{ props:{ // content:String // 这行的意思就是子组件接收的参数一定要是一个字符串类型; // content:[Number,String] // 可以用数组来定义传输参数的类型，可以是字符串/数组; content:{ type:String, required:false,//true说明了这个是必须传的,如果是false,那么不传也可以 default: ‘default value’,//假设不传的时候,会显示默认值‘default value’ validator:function(value){ //自定义校验器：先获取传入的参数值value,要求满足条件,要是没有满足，控制台就会报错 return (value.lenght&gt;5) } } }, props特性指的就是父组件传递一个参数给子组件，同时子组件也定义了相应的props对父组件进行接收；props特性的特点：父组件定义了参数传递content=’hell’，但是在DOM结构里面是看不到的；子组件接收到父组件传递的值之后，就可以直接在子组件用插值表达式或者this.content获取到参数的值了非props特性指的是父组件传递一个参数给子组件，但是子组件没有定义props相关内容在这种情况下：页面会报错，content没有定义无法使用，获取不到参数内容这个属性会展示在子组件最外层的DOM标签的HTML的属性里面原生事件：&lt;child1 @click.native=’handle’&gt;​ 这里绑定的click是一个自定义事件，而不是点击事件，原生点击事件要和div标签绑在一起，先触发了原生click，触发了子组件中的handleChildClick事件，然后在这个事件中，向外触发了自定义事件click，而在父组件中监听了自定义click事件，触发了父组件中的handleClick。 &lt;div id=&quot;root&quot;&gt; &lt;child @click=&apos;handleClick&apos;&gt;&lt;/child&gt; &lt;!--这里不是原生事件，需要触发，是自定义事件--&gt; &lt;/div&gt; Vue.component(&apos;child&apos;,{ template:&apos;&lt;div @click=&quot;handleChildClick&quot;&gt;Child&lt;/div&gt;&apos;,//这里是原生事件 methods:{ handleChildClick:function(){ alert(&apos;handleChildClick&apos;) this.$emit(&apos;click&apos;) //触发自定义事件 } } }) var vm = new Vue({ el:&apos;#root&apos;, methods:{ handleClick:function(){ alert(&apos;click&apos;) } } })在自定义的click后面添加一个事件修饰符native，表示的就是这个click不再是自定义事件，而是一个原生的点击事件。 非父子组件间传值(BUS总线又称发布订阅模式又称观察者模式) Vue.prototype.bus = new Vue()在Vue的prototype上面挂载了一个bus属性，这个属性指向一个vue的实例，只要后面创建vue，每一个都有bus属性，指向同一个实例。 &lt;!--想要两个child之间的值进行传递--&gt; &lt;div id=&quot;root&quot;&gt; &lt;child content=&apos;Alice&apos;&gt;&lt;/child&gt; &lt;child content=&apos;Sunny&apos;&gt;&lt;/child&gt; &lt;/div&gt; //在Vue的prototype上面挂载了一个bus属性，这个属性指向一个vue的实例 Vue.prototype.bus = new Vue() Vue.component(&apos;child&apos;, { data: function () { return { selfContent: this.content } }, props: { content: String //content的内容是从父组件传递过来的，不能直接改变（单向数据流） }, template: &apos;&lt;div @click=&quot;handleClick&quot;&gt;&lt;/div&gt;&apos;, methods: { handleClick: function () { this.bus.$emit(&apos;change&apos;, this.selfContent) //触发事件的时候进行内容传递 } }, // 这是一个生命周期钩子,每个组件被挂载的时候执行的函数,让组件进行监听bus的改变 mounted: function () { var this_ = this this.bus.$on(&apos;change&apos;, function (msg) { this_.selfContent = msg; }) } }) var vm = new Vue({ el: &apos;#root&apos; })插槽 slot如何让父组件用插槽优雅得向子组件传递DOM结构？先在父组件里面插入一个p标签；然后在模板中插入slot标签，slot标签会引用在父组件中插入的内容。slot特性： 在子组件template中直接使用 slot ，可以接收到子组件 child 里面传递DOM结构 Alice；默认内容，如果没有插槽内容，就会显示默认内容或者默认内容； Alice Vue.conponent(‘child’,{ template:&lt;div&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;slot&gt;默认内容&lt;/slot&gt; &lt;/div&gt;}) var vm = new Vue({ el”‘#root’})slot接收内容的时候，是无差别接收的，所以要使用 具名插槽 slot=’name’，也有默认值 通过这种写法，可以一次性传递多个DOM结构，而在子组件中使用具名插槽分别来使用不同部分的DOM结构 &lt;div id=&apos;root&apos;&gt; &lt;body-content&gt; &lt;div slot=&apos;header&apos;&gt;header&lt;/div&gt; &lt;div slot=&apos;footer&apos;&gt;footer&lt;/div&gt; &lt;/body-content&gt; &lt;/div&gt;Vue.conponent(‘body-content’,{ template:&lt;div&gt; &lt;slot name=&#39;header&#39;&gt;default header&lt;/slot&gt; &lt;div class=&#39;content&#39;&gt;content&lt;/div&gt; &lt;slot name=&#39;footer&#39;&gt;default footer&lt;/slot&gt; &lt;/div&gt;})var vm = new Vue({ el”‘#root’}) 作用域插槽 什么时候用这个作用域插槽的应用场景？ 回答：当子组件的DOM结构需要由外部传递进来的时候；子组件可以更方便地向父组件的插槽里面传数据。 首先，父组件调用子组件的时候，给子组件传了一个插槽，这个插槽叫做作用域插槽： 必须以标签包裹；同时这个插槽需要声明要从子组件接受的数据放在slot-scope=’props’；还要告诉子组件一个模板的信息(接收到的数据的展示方式)， 、标签等对这个数据进行展示。 ent(‘child’,{ //子组件 data:function(){ return { list:[1,2,3,4] //循环展示list内容 } }, template:` &lt;/slot&gt; &lt;/ul&gt; &lt;/div&gt;` }) var vm = new Vue({ el:&apos;#root&apos; })动态组件 实现toggle的办法： 常规方法 el: &apos;#root&apos;, data: { type: &apos;child-one&apos; }, methods: { handleBtnClick: function () { this.type = this.type === &apos;child-one&apos; ? &apos;child-two&apos; : &apos;child-one&apos; } } })接下来尝试用动态组件实现 动态组件：根据is里面数据的变化自动加载不同的组件 &lt;div id=&quot;root1&quot;&gt; &lt;component :is=&apos;type&apos;&gt;&lt;/component&gt; &lt;!-- component标签是vue自带的表示动态组件的标签 --&gt; &lt;button @click=&apos;handleBtnClick1&apos;&gt;change&lt;/button&gt; &lt;/div&gt; //和上面的vue代码是一样的 Vue.component(&apos;child-one&apos;, { template: &apos;&lt;div&gt;child-one&lt;/div&gt;&apos; }) Vue.component(&apos;child-two&apos;, { template: &apos;&lt;div&gt;child-two&lt;/div&gt;&apos; }) var vm = new Vue({ el: &apos;#root&apos;, data: { type: &apos;child-one&apos; }, methods: { handleBtnClick: function () { this.type = this.type === &apos;child-one&apos; ? &apos;child-two&apos; : &apos;child-one&apos; } } })​ 这里使用了一个v-once的指令，在组件第一次被渲染的时候，会直接放在内存里面，性能更高，有效提高一些静态内容的展示效率；如果不加v-once的时候，每次切换，都要在底层先销毁一个组件，再创建一个组件，耗费了一定的性能。 Vue.component(&apos;child-one&apos;, { template: &apos;&lt;div v-once&gt;child-one&lt;/div&gt;&apos; //和上面代码唯一不同的就是这里添加了v-once }) Vue.component(&apos;child-two&apos;, { template: &apos;&lt;div v-once&gt;child-two&lt;/div&gt;&apos; }) var vm = new Vue({ el: &apos;#root1&apos;, data: { type: &apos;child-two&apos; }, methods: { handleBtnClick1: function () { this.type = this.type === &apos;child-one&apos; ? &apos;child-two&apos; : &apos;child-one&apos; } } })","categories":[],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/tags/VUE/"}]},{"title":"微信小程序的学习","slug":"微信小程序的学习","date":"2019-09-13T07:53:09.000Z","updated":"2019-09-30T13:38:42.344Z","comments":true,"path":"2019/09/13/微信小程序的学习/","link":"","permalink":"http://yoursite.com/2019/09/13/微信小程序的学习/","excerpt":"#微信小程序的学习","text":"#微信小程序的学习 1.小程序的基本配置参考官方文档，（国人设计的，真心好用，通俗易懂） 2.小程序的双线程模型小程序的宿主环境是微信客户端， 宿主环境为了执行小程序的各种文件：wxml文件，wxss文件，js文件。 提供了小程序的双线程模型 双线程模型 WXML模块和WXSS样式运行于渲染层，渲染层使用WebView线程渲染(一个程序有多个页面，会使用多个webview的线程) JS脚本运行于逻辑层，逻辑层使用JsCore运行JS脚本 这两个线程都会由微信客户端进行中转交互 界面渲染的整体流程 在渲染层，宿主环境会把WXML转化成对应的JS对象 将JS对象再次转成真实的DOM树，交由渲染层线程渲染 数据变化是，逻辑层提供最新的变化数据，JS对象发生变化比较进行DIFF算法对比 将最新变化的内容反映到真实的DOM树中，更新UI 3.注册小程序流程注册APP时做些什么？ 判断小程序的进入场景 监听生命周期函数，在生命周期中执行对应的业务逻辑，比如在某个生命周期函数中获取微信用户的信息。 因为App()实例只有一个，并且是全局共享的（单例对象），所以我们可以将一些共享数据放在这里。 如何确定场景?在onLaunch和onShow生命周期回调函数中,会有options参数，其中有scene值 获取微信用户的基本信息的方式： wx.getUserInfo – 即将废弃的接口； button组件 – 将open-type改成getUserInfo，并且绑定bindgetuserinfo事件去获取； 使用open-data组件展示用户信息； 注册Page时做什么呢？ 在生命周期函数中发送网络请求，从服务器获取数据； 初始化一些数据，以方便被wxml引用展示； 监听wxml中的事件，绑定对应的事件函数； 其他一些监听（比如页面滚动、上拉刷新、下拉加载更多等） 4.WXSS&amp;&amp;WXML&amp;&amp;WXSWXSS的扩展尺寸单位 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px共有750个物理像素，则750rpx = 375px = 750物理像素1rpx = 0.5px = 1物理像素。 建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉的标准。 WXSS的扩展样式导入 在某些情况下，我们可能会将样式分在多个wxss文件中，方便对样式的管理。这个时候，我们就可以使用样式导入，来让单独的wxss生效我们可以在一个wxss中导入另一个wxss文件： 使用@import进行导入 @import后跟需要导入的外联样式表的相对路径（或者绝对路径也可以），用;表示语句结束。可以在app.wxss中导入这个样式，也可以在page.wxss导入这个样式#####官方样式库为了减少开发者样式开发的工作量，小程序官方提供了WeUI.wxss基本样式库 WXML的基本语法WXML基本格式： 类似于HTML代码：比如可以写成单标签，也可以写成双标签 必须有严格的闭合：没有闭合会导致编译错误 大小写敏感：class和Class是不同的属性开发中, 界面上展示的数据并不是写死的, 而是会根据服务器返回的数据, 或者用户的操作来进行改变.如果使用原生JS或者jQuery的话, 我们需要通过操作DOM来进行界面的更新.小程序和Vue/React一样, 提供了插值语法: Mustache语法(双大括号)Mustache语法不仅仅可以直接显示数据, 也可以使用表达式,并且可以绑定到属性.逻辑判断 wx:if – wx:elif – wx:else某些时候, 我们需要根据条件来决定一些内容是否渲染：当条件为true时, view组件会渲染出来当条件为false时, view组件不会渲染出来有多个条件:使用wx:if-wx:elif-wx:elsehidden属性:hidden是所有的组件都默认拥有的属性,当hidden属性为true时, 组件会被隐藏当hidden属性为false时, 组件会显示出来hidden和wx:if的区别hidden控制隐藏和显示是控制是否添加hidden属性wx:if是控制组件是否渲染的 列表渲染 – wx:for基础我们知道，在实际开发中，服务器经常返回各种列表数据，我们不可能一一从列表中取出数据进行展示；需要通过for循环的方式，遍历所有的数据，一次性进行展示；在组件中，我们可以使用wx:for来遍历一个数组 （字符串 - 数字）默认情况下，遍历后在wxml中可以使用一个变量index，保存的是当前遍历数据的下标值。数组中对应某项的数据，使用变量名item获取。 block标签什么是block标签？某些情况下，我们需要使用 wx:if 或 wx:for时，可能需要包裹一组组件标签我们希望对这一组组件标签进行整体的操作，使用一个view标签或者block标签包裹 block标签的意义并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。12345678使用block有两个好处：1）将需要进行遍历或者判断的内容进行包裹。2）将遍历和判断的属性放在block便签中，不影响普通属性的阅读，提高代码的可读性。#### 列表渲染 – item/index名称默认情况下，item – index的名字是固定的但是某些情况下，我们可能想使用其他名称,或者当出现多层遍历时，名字会重复这个时候，我们可以指定item和index的名称,```wx:for-item=&quot;指定名称&quot;，wx:for-index=&quot;指定名称&quot; 列表渲染 – key作用这个其实和小程序内部也使用了虚拟DOM有关系（和Vue、React很相似）。当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点,我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的。即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？所以我们需要使用key来给每个节点做一个唯一标识Diff算法就可以正确的识别此节点,找到正确的位置区插入新的节点。所以一句话，key的作用主要是为了高效的更新虚拟DOM。 模板用法WXML提供模板（template），可以在模板中定义代码片段，在不同的地方调用。(是一种wxml代码的复用机制)  使用 name 属性，作为模板的名字, 然后在 &lt;template/&gt; 内定义代码片段 wxml的引入小程序wxml中提供了两种引入文件的方式：import和includeImport引入：import 可以在该文件中使用目标文件定义的 template注意：wxml中不能递归引入（也就是A引入了B的template，不会引入B中引入C的template）include引入:include 可以将目标文件中除了 &lt;template/&gt; &lt;wxs/&gt;外的整个代码引入，相当于是拷贝到 include 位置. wxs模块WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。 为什么要设计WXS语言呢？在WXML中是不能直接调用Page/Component中定义的函数的.但是某些情况, 我们可以希望使用函数来处理WXML中的数据(类似于Vue中的过滤器)，这个时候就使用WXS了.WXS使用的限制和特点： WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API。 WXS 函数不能作为组件的事件回调。 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。 WXS有两种写法： 写在&lt;wxs&gt;标签中 写在以.wxs结尾的文件中 5.组件化开发类似于页面，自定义组件由 json wxml wxss js 4个文件组成。 自定义组件的步骤：1.首先需要在 json 文件中进行自定义组件声明（将component 字段设为 true 可这一组文件设为自定义组件）：2.在wxml中编写属于我们组件自己的模板3.在wxss中编写属于我们组件自己的相关样式4.在js文件中, 可以定义数据或组件内部的相关逻辑(后续我们再使用) 使用自定义组件和细节注意事项一些需要注意的细节：因为 WXML 节点标签名只能是 小写字母、中划线和下划线 的组合，所以自定义组件的标签名也只能包含这些字符。自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用usingComponents 字段）。自定义组件和页面所在项目根目录名 不能以“wx-”为前缀，否则会报错。如果在app.json的usingComponents声明某个组件，那么所有页面和组件可以直接使用该组件。 组件的样式细节课题一：组件内的样式 对 外部样式 的影响结论一：组件内的class样式，只对组件wxml内的节点生效, 对于引用组件的Page页面不生效。结论二：组件内不能使用id选择器、属性选择器、标签选择器 课题二：外部样式 对 组件内样式 的影响结论一：外部使用class的样式，只对外部wxml的class生效，对组件内是不生效的结论二：外部使用了id选择器、属性选择器不会对组件内产生影响结论三：外部使用了标签选择器，会对组件内产生影响 整体结论:组件内的class样式和组件外的class样式, 默认是有一个隔离效果的；为了防止样式的错乱，官方不推荐使用id、属性、标签选择器； 课题三：如何让class可以相互影响在Component对象中，可以传入一个options属性，其中options属性中有一个styleIsolation（隔离）属性。styleIsolation有三个取值： isolated 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（默认取值）； apply-shared 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面； shared 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 其他一些相关样式细节，参考官网 组件和页面通信很多情况下，组件内展示的内容（数据、样式、标签），并不是在组件内写死的，而且可以由使用者来决定。 向组件传递数据 - properties给组件传递数据：大部分情况下，组件只负责布局和样式，内容是由使用组件的对象决定的。所以，我们经常需要从外部传递数据给我们的组件，让我们的组件来进行展示。如何传递呢？使用properties属性：支持的类型：String、Number、BooleanObject、Array、null（不限制类型） 向组件传递样式 - externalClasses给组件传递样式：有时候，我们不希望将样式在组件内固定不变，而是外部可以决定样式。这个时候，我们可以使用externalClasses属性：1.在Component对象中，定义externalClasses属性2.在组件内的wxml中使用externalClasses属性中的class3.在页面中传入对应的class，并且给这个class设置样式 组件向外传递事件 – 自定义事件有时候是自定义组件内部发生了事件，需要告知使用者，这个时候可以使用自定义事件页面直接调用组件方法:this.selectComponent 什么是插槽slot翻译为插槽：插槽的目的是让我们原来的设备具备更多的扩展性。 组件的插槽：组件的插槽也是为了让我们封装的组件更加具有扩展性。让使用者可以决定组件内部的一些内容到底展示什么。 单个插槽的使用除了内容和样式可能由外界决定之外，也可能外界想决定显示的方式比如我们有一个组件定义了头部和尾部，但是中间的内容可能是一段文字，也可能是一张图片，或者是一个进度条。在不确定外界想插入什么其他组件的前提下，我们可以在组件内预留插槽 多个插槽的使用有时候为了让组件更加灵活, 我们需要定义多个插槽： Component构造器Component构造器用户创建我们的自定义组件对象, 调用Component时, 可以传入属性、数据、方法等 小程序得系统API网络请求 – 基本使用微信提供了专属的API接口,用于网络请求: wx.request(Object object)比较关键的几个属性解析:url: 必传, 不然请求什么.data: 请求参数method: 请求的方式success: 成功时的回调fail: 失败时的回调 网络请求 – 请求封装目前我们采用的网络请求是非常古老的请求方式, 我们将它封装成Promise的方式。 展示弹窗小程序中展示弹窗有四种方式: showToast、showModal、showLoading、showActionSheet 页面分享分享是小程序扩散的一种重要方式，小程序中有两种分享方式：点击右上角的菜单按钮，之后点击转发，或者点击某一个按钮，直接转发当我们转发给好友一个小程序时，通常小程序中会显示一些信息：如何决定这些信息的展示呢？通过 onShareAppMessage 小程序的登录流程小程序登录流程图：1.调用wx.login获取code2.调用wx.request发送code到我们自己的服务器（我们自己的服务器会返回一个登录态的标识，比如token）3.将登录态的标识token进行存储，以便下次使用4.请求需要登录态标识的接口时，携带token 界面跳转界面的跳转有两种方式：通过navigator组件 和 通过wx的API跳转navigator组件主要就是用于界面的跳转的 open-type的取值：redirect：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面，并且不能返回。（不是一个压栈）switchTab：跳转到 tabBar 页面，并关闭其他所有非tabBar 页面。（需要在tabBar中定义的）eLaunch：关闭所有的页面，打开应用中某个页面。（直接展示某个页面，并且可以跳转到tabBar页面） 导航返回有两个属性来起作用：open-type：navigateBack（表示该navigator组件用于返回）delta：返回的层级（指定返回的层级，open-type必须是navigateBack才生效） 如何在界面跳转过程中我们需要相互传递一些数据，应该如何完成呢？ 数据传递 – 传递过程首页 -&gt; 详情页：通过修改URL传递参数详情页 -&gt; 首页：返回时携带数据有两个问题需要考虑 问题一: 在什么地方修改数据 如果你是监听按钮或者navigator的点击来返回时, 可以通过bindtap来映射到某个函数, 在函数中完成. 但是这种方式不能监听左上角返回按钮的点击. 所以我们选择在onUnload中修改数据问题二: 如何修改数据 小程序并没有提供直接修改数据的方法. 但是可以通过getCurrentPages来获取所有的页面, 然后使用页面对象的setData({})函数来修改 代码的跳转和返回很多情况下，我们并不喜欢使用navigator组件来进行跳转：可能我们希望用户点击了某个button或者view时，对该button或者view进行监听之后，通过相关的代码逻辑实现跳转对此，微信也提供了对应的API接口：wx.navigateTo(url[, ])wx.navigateBack([delta]) 至此微信小程序基础知识过了一遍，更多知识参考官方文档。（下面开始项目实战）","categories":[],"tags":[{"name":"小程序 微信","slug":"小程序-微信","permalink":"http://yoursite.com/tags/小程序-微信/"}]},{"title":"【转载】hexo 文章保存为草稿","slug":"hexo文章保存为草稿","date":"2019-09-12T07:40:45.000Z","updated":"2019-09-28T16:32:11.852Z","comments":true,"path":"2019/09/12/hexo文章保存为草稿/","link":"","permalink":"http://yoursite.com/2019/09/12/hexo文章保存为草稿/","excerpt":"转载自： https://novnan.github.io/Hexo/hexo-draft/","text":"转载自： https://novnan.github.io/Hexo/hexo-draft/ 传统建立文章方式一般我们都会使用 new ``` 来建立文章，这种建立方法会将新文章建立在 source/_posts 目录下，当使用 hexo generate 编译 markdown 文件时，会将其 HTML 结果编译在 public 目录下，之后 hexo deploy 将会把 public 目录下所有文章部署到 GitHub，这是我们熟悉的 Hexo 流程。12345这种建立文章方式的缺点是：若我们同时编辑多篇文章，只要其中一篇文章尚未编辑完成，也会随着 hexo deploy 一起部署到 GitHub，也就是 GitHub 可能会看到我们尚未完成的文章。## 建立文章草稿```$ hexo new draft &lt;title&gt; Hexo 另外提供 draft 机制，它的原理是新文章将建立在 source/_drafts 目录下，因此 hexo generate 并不会将其编译到 public 目录下，所以 hexo deploy 也不会将其部署到 GitHub。 本机预览草稿hexo S --draft```1234虽然 hexo generate 不会编译 source/_drafts 目录下的文章，但 Hexo 的 Hexo server 另外提供 --draft 参数，这让我们只要搭配 hexo-browsersync plugins，就可以达到一边编辑 markdown 文章，一边使用浏览器预览的目的。## 将草稿发布为正式文章```$ hexo P &lt;filename&gt; 其中 &lt;filename&gt; 为不包含 md 后缀的文章名称。它的原理只是将文章从 source/_drafts 移动到 source/_posts 而已。 之后的 hexo generate 与 hexo deploy 的用法就完全一样了。 若日后想将正式文章转为为草稿，只需手动将文章从 source/_posts 目录移动到 source/_drafts 目录即可。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"[终于创建好了我的博客]","slug":"终于创建好了我的博客","date":"2019-09-10T17:27:25.000Z","updated":"2019-09-26T13:47:37.067Z","comments":true,"path":"2019/09/11/终于创建好了我的博客/","link":"","permalink":"http://yoursite.com/2019/09/11/终于创建好了我的博客/","excerpt":"","text":"哈哈哈哈，兜兜转转，折腾了好久，换了好多种主题和Blog的框架终于搞定了自己的Blog，记录下自己。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]