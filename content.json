[{"title":"ES6复习及学习","slug":"ES6复习及学习","date":"2019-09-30T02:48:31.000Z","updated":"2019-10-13T02:52:16.607Z","comments":true,"path":"2019/09/30/ES6复习及学习/","link":"","permalink":"http://yoursite.com/2019/09/30/ES6复习及学习/","excerpt":"","text":"","categories":[],"tags":[{"name":"ES6 javascript","slug":"ES6-javascript","permalink":"http://yoursite.com/tags/ES6-javascript/"}]},{"title":"Vue的复习及一个新的项目练手","slug":"Vue的复习及一个新的项目练手","date":"2019-09-18T13:57:05.000Z","updated":"2019-10-30T15:38:38.545Z","comments":true,"path":"2019/09/18/Vue的复习及一个新的项目练手/","link":"","permalink":"http://yoursite.com/2019/09/18/Vue的复习及一个新的项目练手/","excerpt":"","text":"创造一个vue实例123456789var app = new Vue(&#123; el:'#app', data:&#123;//用于存储数据的 &#125;, methods:&#123;//用于定义事件的 &#125;, components:&#123;//用来注册局部组件 &#125;&#125;) VUE的指令1. v-on： 用于绑定事件的（简写@：）12 2. v-model指令可以实现表单元素和model中的数据的双向绑定（只能用于表单元素） 3. v-bind: 用于绑定属性的指令（简写 ：）[单向绑定]4. v-html 插入一个HTML，v-text插入文本字符串，该方法没有闪烁问题，而使用插值表达式存在闪烁问题（v-text会覆盖元素中原来的内容，但插值表达式只会替换）v-if 和 v-show指令都是用于条件性地渲染一块内容。不同的是：v-if特点：每次都会重新删除或创建元素，有着较高的切换性能消耗。v-show特点：每次不会重新进行DOM的删除和创建操作，只是切换了元素的display：none的样式。有着较高的初始渲染消耗。v-if可以和v-else,v-else-if一起使用 定义vue组件1.使用Vue.component（’组件名称’,创建出来的组件模板对象） Vue.extend({template:模板结构})若Vue.component定义时使用了驼峰命名法，则使用组件用标签形式时，需将大写改小写中间加-2.使用字面量创建Vue.compnent(“名称”,{template:”模板结构”})，使用templeta标签引用不管使用那种方式创建出的组件，组件中的template内容有且只有一个根元素组件中有自己的date和methods数据，组件中的date必须是个方法，且这个方法内部必须返回一个对象才行 vue实现TodoList:MVVM模式v-model作用:input里面的value值和vue实例中的inputValue进行了双向的数据绑定 &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&apos;inputValue&apos;&gt; &lt;button v-on:click=&apos;handleBtnClick&apos;&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&apos;item in list&apos;&gt; &lt;/li&gt; &lt;/ul&gt; /div&gt; var app = new Vue({ el : &apos;#app&apos;, data : { list : [], inputValue:&apos;&apos; }, methods:{ handleBtnClick:function(){ this.list.push(this.inputValue) this.inputValue=&apos;&apos; } } })前端组件化：全局组件和局部组件全局组件 // 全局组件，名称叫做TodoItem，内容是li标签 // 使用的时候，TodoItem 等价于 todo-item 来使用 Vue.component(&apos;TodoItem&apos;,{ template:&apos;&lt;li&gt;hello world&lt;/li&gt;&apos; })局部组件 // 局部组件,不能直接使用，需要注册到下面的应用实例里面 var TodoItem = { template:&apos;&lt;li&gt;hello world&lt;/li&gt;&apos;, } } //在vue实例中注册conponent var app = new Vue({ el : &apos;#app&apos;, components:{ TodoItem:TodoItem }})前端组件化：简单的组件间传值实现todolist的简单功能，单击添加的内容，进行删除 子组件向父组件传值：在子组件的模板template中添加监听事件 v-on/@，同时在子组件中定义绑定的事件子组件中的数据是由v-bind绑定的父组件中的data决定的，所以需要子组件绑定向外触发的事件，改变父组件中的值$emit()父组件向子组件传值：v-bind/:方式进行数据传递，同时子组件props要进行接收 提交 &lt;todo-item :content=’item’ :index=’index’ v-for=’(item,index) in list’ @delete=’handleItemDelete’&gt; var TodoItem = { //子组件传值，在DOM中绑定的内容可以用子组件中的props接收 props:[‘content’,’index’], //定义子组件的内容，同时绑定点击事件，在标签中显示绑定数据content的内容 template:’&lt;li @click=”handleItemClick”&gt; header.intro-header{ position: relative; background-image: url('/img/home.jpg') } &lt;a class=&quot;tag&quot; href=&quot;/tags/#&lt; 黑马视频 &gt;知识点&quot; title=&quot;&lt; 黑马视频 &gt;知识点&quot;&gt;&lt; 黑马视频 &gt;知识点&lt;/a&gt; &lt;/div&gt; &lt;h1&gt;DOM相关知识点整理1&lt;/h1&gt; &lt;h2 class=&quot;subheading&quot;&gt;&lt;/h2&gt; &lt;span class=&quot;meta&quot;&gt;Posted by CodingWithAlice on June 23, 2019&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Post Container --&gt; &lt;div class=&quot; col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container&quot;&gt; &lt;h3 id=&quot;本文概要如下&quot;&gt;本文概要如下：&lt;/h3&gt; DOM树：把html页面或者是xml文件看成是一个文档，文档就是一个对象，这个文档中所有的标签都是元素，元素也可以看成是对象,标签(元素，对象)有很多，还有嵌套的关系,组成的这种层次结构，可以模拟成树形结构图，简称：树状图，就是DOM树。 DOM对象：通过DOM方式获取的元素得到的对象 获取元素多种方式： 根据 id属性 的值获取元素，返回来的是一个元素对象； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.getElementById(&quot;id属性的值&quot;);&lt;/code&gt;&lt;/p&gt; 根据 标签名字 获取元素，返回来的是一个伪数组，返回具有指定标签名的元素子元素集合；document.getElementsByTagName(\"标签名字\"); &lt;p&gt;&lt;strong&gt;下面的几个,有的浏览器不支持(ie8)&lt;/strong&gt;&lt;/p&gt; 根据 name属性 的值获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.getElementsByName(&quot;name属性的值&quot;)&lt;/code&gt;&lt;/p&gt; 根据 类样式 的名字来获取元素，返回来的是一个伪数组，里面保存了多个的DOM对象； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.getElementsByClassName(&quot;类样式的名字&quot;)&lt;/code&gt;&lt;/p&gt; 根据 选择器 获取元素，返回来的是一个元素对象，文档中匹配到指定的元素的第一个对象； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.querySelector(&quot;选择器的名字#btn&quot;); &lt;/code&gt;&lt;/p&gt; 根据 选择器 获取元素，返回来的是一个伪数组，文档中匹配到指定的元素的对象集合； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.querySelectorAll(&quot;选择器的名字.cls&quot;) &lt;/code&gt;&lt;/p&gt; 获取boby、title、html标签 console.log(document.body); //获取的是元素--标签 console.log(document.title); //标签中的值 console.log(document.documentElement);//获取根元素html 操作基本标签的属性 src,title,alt,href,id属性 操作表单标签的属性吧+21 name,value,type,checked,selected,disabled,readonly 元素的样式操作 对象.style.属性=值; 对象.className=值; 为元素添加事件的操作：有事件源，触发和响应； 例如：按钮被点击,弹出对话框 其中：按钮—-&gt;事件源 点击—-&gt;事件名字 被点了—&gt;触发了 弹框了—&gt;响应 this的指向改变方法： 使用ES6的箭头函数，this在定义的时候被指定； 在函数内部使用_this=this;来保存this的指向； 使用apply()、call()、bind()； new实例化一个对象，this指向新对象； 接下来是详细分析介绍： DOM经常进行的操作： ​ • 获取元素 ​ • 动态创建元素 ​ • 对元素进行操作(设置其属性或调用其方法) ​ • 事件(什么时机做相应的操作) &lt;input type=\"button\" value=\"弹框\" onclick=\"alert('哈哈,我又变帅了')\" /&gt; 等价于 &lt;input type=\"button\" value=\"显示效果\" id=\"btn\"/&gt; //document.getElementById(\"id属性的值\");返回的是一个元素对象 document.getElementById(\"btn\").onclick=function () { alert(\"哈哈,我又变帅了\"); }; 等价于 var btnObj=document.getElementById(\"btn\"); btnObj.onclick=function(){ alert(\"这是分成两行代码的方式\"); } HTML：展示信息，展示数据的 XML：侧重于存储数据 根元素:html标签 元素(element)：页面中的所有的标签都是元素，元素可以看成是对象 文档 document：一个网页可以称为文档；页面中的顶级对象； 节点 Node：网页中的所有内容都是节点（标签、属性、文本[文字、换行、空格、回车]、注释等） 节点的属性：标签的属性；作用：为了将来获取很多节点，得到节点中的标签（元素），识别节点中的标签元素 点击事件：如下以案例举例出现的情况以及其功能 案例1：点击按钮显示图片：点击按钮的时候设置img标签的src属性有一个图片的路径 &lt;input type=\"button\" value=\"显示图片\" id=\"btn\"/&gt; &lt;img src=\"\" alt=\"\" id=\"im\" /&gt; var btnObj=document.getElementById(\"btn\"); //为按钮注册点击事件,添加事件处理函数 btnObj.onclick=function () { var imObj=document.getElementById(\"im\"); imObj.src=\"images/liuyan.jpg\"; imObj.width=\"300\"; imObj.height=\"400\"; }; 案例2：点击按钮，修改p标签的显示内容 &lt;input type=\"button\" value=\"设置p的内容\" id=\"btn\"/&gt; &lt;p id=\"p1\"&gt;我是一个p标签&lt;/p&gt; //根据id获取按钮,为按钮注册点击事件,添加事件处理函数 document.getElementById(\"btn\").onclick=function () { //根据id获取p标签,设置内容 document.getElementById(\"p1\").innerText=\"这是一个p\"; }; 注意技巧1： 凡是成对的标签,中间的文本内容,设置的时候,都使用 innerText 这个属性的方式； 案例3：点击按钮修改a标签的地址和热点文字 &lt;input type=\"button\" value=\"显示效果\" id=\"btn\"/&gt; &lt;a id=\"ak\" href=\"https://www.jiumodiary.com/\"&gt;鸠摩搜书&lt;/a&gt; //注册点击事件,添加事件处理函数 document.getElementById(\"btn\").onclick = function () { //设置href属性 document.getElementById(\"ak\").href = \"https://codingwithalice.github.io/\"; //设置文字内容 document.getElementById(\"ak\").innerText = \"CodingWithAlice\"; }; 可对javascript代码进行优化： //上面的代码，获取了两次id为ak的元素，增加了浏览器的负担。 //优化后的: document.getElementById(\"btn\").onclick = function () { //设置href属性，设置文字内容 var aObj = document.getElementById(\"ak\"); aObj.href = \"https://codingwithalice.github.io/\"; aObj.innerText = \"CodingWithAlice\"; }; 案例4：点击按钮设置多个p标签的文字内容 &lt;input type=\"button\" value=\"显示效果\" id=\"btn\"/&gt; &lt;div id=\"dv1\"&gt; &lt;p&gt;CtrlCoder&lt;/p&gt; &lt;p&gt;CtrlCoder&lt;/p&gt; &lt;/div&gt; &lt;div id=\"dv2\"&gt; &lt;p&gt;CodingWithAlice&lt;/p&gt; &lt;p&gt;CodingWithAlice&lt;/p&gt; &lt;p&gt;CodingWithAlice&lt;/p&gt; &lt;/div&gt; document.getElementById(\"btn\").onclick=function () { //根据标签名字获取标签,返回的是一个伪数组 var pObjs= document.getElementsByTagName(\"p\"); //循环遍历这个数组 for(var i=0;i&lt;pObjs.length;i++){ //每个p标签,设置文字 pObjs[i].innerText=\"我们都是p\"; } }; 案例5：点击按钮改变图片的alt和titile &lt;input type=\"button\" value=\"显示效果\" id=\"btn\"/&gt; &lt;img src=\"images/cangjingkong.jpg\" alt=\"CtrlCoder\" title=\"CodingWithAlice\"/&gt; document.getElementById(\"btn\").onclick = function () { //没有给img id名称，可以用tagname获取，但是一定要注意返回的是一个伪数组 var imgObjs = document.getElementsByTagName(\"img\"); imgObjs[0].alt = \"改了\";//调用的时候以数组的形式调用 imgObjs[0].title = \"实现吧\"; }; 案例6：点击按钮修改文本框的值 &lt;input type=\"button\" value=\"修改文本框的值\" id=\"btn\"/&gt;&lt;br/&gt; &lt;input type=\"text\" value=\"\"/&gt;&lt;br/&gt; &lt;input type=\"text\" value=\"\"/&gt;&lt;br/&gt; &lt;input type=\"text\" value=\"\"/&gt;&lt;br/&gt; &lt;input type=\"text\" value=\"\"/&gt;&lt;br/&gt; document.getElementById(\"btn\").onclick = function () { //获取所有的文本框，包含了第一个type为button var inputs = document.getElementsByTagName(\"input\"); for (var i = 0; i &lt; inputs.length; i++) { //用该元素的type属性判断这个元素是不是按钮 if (inputs[i].type != \"button\") { inputs[i].value = \"CodingWithAlice\"; } } }; 案例7：显示与隐藏 &lt;style&gt; div{ width: 300px; height: 200px; background-color: darkmagenta; } &lt;/style&gt; &lt;input type=\"button\" value=\"隐藏\" id=\"btn\"/&gt; &lt;input type=\"button\" value=\"显示\" id=\"btn2\"/&gt; &lt;div id=\"dv\"&gt;&lt;/div&gt; document.getElementById(\"btn\").onclick=function () { document.getElementById(\"dv\").style.display=\"none\"; }; document.getElementById(\"btn2\").onclick=function () { document.getElementById(\"dv\").style.display=\"block\"; }; 案例7：显示与隐藏优化：一个按钮的写法 &lt;style&gt; div{ width: 300px; height: 200px; background-color: darkmagenta; } .cls { display: none; } &lt;/style&gt; &lt;input type=\"button\" value=\"隐藏\" id=\"btn\"/&gt; &lt;div id=\"dv\"&gt;&lt;/div&gt; //点击按钮,通过类样式的方式设置div的显示和隐藏 document.getElementById(\"btn\").onclick = function () { //判断的是div是否应用了类样式 if (document.getElementById(\"dv\").className != \"cls\") { //没有应用类样式，现在是显示的,应该隐藏 document.getElementById(\"dv\").className = \"cls\"; //执行完上一句，就隐藏了，按钮改变 this.value = \"显示\"; } else { document.getElementById(\"dv\").className = \"\"; //执行完上一句，就显示了，按钮改变 this.value = \"隐藏\"; } }; 案例8：开关灯，body标签背景颜色 &lt;style&gt; .cls {background-color: black;} &lt;/style&gt; &lt;input type=\"button\" value=\"开/关灯\" id=\"btn\"/&gt; document.getElementById(\"btn\").onclick = function () { document.body.className = document.body.className != \"cls\" ? \"cls\" : \"\"; }; 案例9：单选和多选和下拉菜单 //单选 &lt;input type=\"button\" value=\"修改性别\" id=\"btn1\"/&gt; &lt;input type=\"radio\" value=\"1\" name=\"sex\"/&gt;男 &lt;input type=\"radio\" value=\"2\" name=\"sex\" id=\"rad1\"/&gt;女 &lt;input type=\"radio\" value=\"3\" name=\"sex\"/&gt;保密 document.getElementById(\"btn1\").onclick = function () { document.getElementById(\"rad1\").checked = true; }; 注意技巧2： 在表单标签中,如果属性和值只有一个，并且值是这个属性本身，那么在写js代码，DOM操作的时候，这个属性值，是布尔类型就可以了。 //多选 &lt;input type=\"button\" value=\"选择兴趣\" id=\"btn2\"/&gt; &lt;input type=\"checkbox\" value=\"1\" name=\"xingqu\" /&gt;吃饭 &lt;input type=\"checkbox\" value=\"2\" name=\"xingqu\" id=\"ck1\" /&gt;睡觉 &lt;input type=\"checkbox\" value=\"3\" name=\"xingqu\" id=\"ck2\" /&gt;打豆豆 document.getElementById(\"btn2\").onclick=function () { document.getElementById(\"ck1\").checked=true; document.getElementById(\"ck2\").checked=true; }; //下拉菜单 &lt;input type=\"button\" value=\"点菜\" id=\"btn\"/&gt; &lt;select name=\"\" id=\"ss\"&gt; &lt;option value=\"1\"&gt;油炸榴莲&lt;/option&gt; &lt;option value=\"2\"&gt;爆炒臭豆腐&lt;/option&gt; &lt;option value=\"3\"&gt;清蒸助教&lt;/option&gt; &lt;option value=\"4\" id=\"op1\"&gt;凉拌班主任&lt;/option&gt; &lt;option value=\"5\"&gt;红烧小苏&lt;/option&gt; &lt;/select&gt; document.getElementById(\"btn\").onclick=function () { //点击按钮选择菜 document.getElementById(\"op1\").selected=true; }; 案例10：改变文本域内的值 &lt;textarea name=\"\" id=\"tt\" cols=\"30\" rows=\"10\" readonly=\"readonly\"/disabled=“disabled”/readonly/disabled &gt; 注册用户的协议:某人问智者,大师:您觉得怎么做才是最快乐的?回答说:不要和愚者辩论这个人说:我不这么认为!大师说:您说的对. &lt;/textarea&gt; &lt;input type=\"button\" value=\"注册\" id=\"btn2\"/&gt; document.getElementById(\"btn2\").onclick=function () { //推荐使用value，textarea是表单标签。 document.getElementById(\"tt\").value=\"CodingWithAlice\"; //document.getElementById(\"tt\").innerText=\"哈哈\"; }; 案例11：点击小图(保留),显示大图 &lt;a href=\"images/1.jpg\" id=\"ak\"&gt; &lt;img src=\"images/1-small.jpg\" alt=\"\"&gt; &lt;/a&gt; &lt;img src=\"\" alt=\"\" id=\"big\"&gt; //保证小图的保留 //点击小图,下面显示大图 //点击超链接触发事件 document.getElementById(\"ak\").onclick=function () { document.getElementById(\"big\").src=this.href; return false;//保证小图的保留 }; 相册操作： &lt;ul id=\"imagegallery\"&gt; &lt;li&gt; &lt;a href=\"images/1.jpg\" title=\"A\"&gt; &lt;img src=\"images/1-small.jpg\" width=\"100\" alt=\"1\"/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/2.jpg\" title=\"B\"&gt; &lt;img src=\"images/2-small.jpg\" width=\"100\" alt=\"2\"/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/3.jpg\" title=\"C\"&gt; &lt;img src=\"images/3-small.jpg\" width=\"100\" alt=\"3\"/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/4.jpg\" title=\"D\"&gt; &lt;img src=\"images/4-small.jpg\" width=\"100\" alt=\"4\"/&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;img id=\"image\" src=\"images/placeholder.png\" alt=\"\" width=\"450\"/&gt;//点击链接a后显示大图的标签 &lt;p id=\"des\"&gt;选择一个图片&lt;/p&gt; //第一步：点击a标签,把a标签中的href的属性值给id为image的src属性 //第二步：把a的title属性的值给id为des的p标签赋值 var aObjs=document.getElementById(\"imagegallery\").getElementsByTagName(\"a\"); //循环遍历所有的a标签 for(var i=0;i&lt;aObjs.length;i++){ //为每个a标签注册点击事件 aObjs[i].onclick=function () { document.getElementById(\"image\").src=this.href; document.getElementById(\"des\").innerText=this.title; //阻止超链接默认的跳转 return false; }; } 案例12：隔行变色，奇红偶黄 &lt;input type=\"button\" value=\"隔行变色\" id=\"btn\"/&gt; &lt;ul id=\"uu\"&gt; &lt;li&gt;红旗&lt;/li&gt; &lt;li&gt;五菱宏光&lt;/li&gt; &lt;li&gt;奔驰&lt;/li&gt; &lt;li&gt;兰博基尼&lt;/li&gt; &lt;li&gt;哈弗&lt;/li&gt; &lt;/ul&gt; //第一种方法 document.getElementById(\"btn\").onclick=function () { //获取所有的li标签 var list=document.getElementById(\"uu\").getElementsByTagName(\"li\"); for(var i=0;i&lt;list.length;i++){ if(i%2==0){ list[i].style.backgroundColor=\"red\"; }else{ list[i].style.backgroundColor=\"yellow\"; } } }; //第二种方法：简写，善于利用三元表达式 document.getElementById(\"btn\").onclick = function () { //获取所有的li标签 var list = document.getElementById(\"uu\").getElementsByTagName(\"li\"); for (var i = 0; i &lt; list.length; i++) { list[i].style.backgroundColor = i % 2 == 0 ? \"red\" : \"yellow\"; } }; 案例13：排他功能 &lt;input type=\"button\" value=\"没怀孕\"/&gt; &lt;input type=\"button\" value=\"没怀孕\"/&gt; &lt;input type=\"button\" value=\"没怀孕\"/&gt; var btnObjs = document.getElementsByTagName(\"input\"); for (var i = 0; i &lt; btnObjs.length; i++) { //每个事件包括两件事情 btnObjs[i].onclick = function () { //第一：把所有的按钮的value值设置为默认的值:没怀孕 for (var j = 0; j &lt; btnObjs.length; j++) { btnObjs[j].value = \"没怀孕\"; } //第二：当前被点击的按钮设置为:怀孕了 this.value = \"怀孕了\"; }; } 注意技巧3： 设置被点击按钮的时候，不能用btnObjs[i].value ，因为事件是在触发的时候执行的，而 for 循环是在页面加载的时候执行完毕了，触发时间的时候，i=btnObjs.length 案例14：阻止超链接跳转 &lt;a href=\"images/lb1.jpg\" id='a1'&gt;&lt;img src=\"images/content_bg.jpg\" alt=\"\" id='im'&gt;&lt;/a&gt; //方法1： document.getElementById('im').onclick=function(){ this.src=document.getElementById('a1').href; return false;//阻止链接默认跳转 } &lt;!--方法2：return flase 写在行内式中--&gt; &lt;a href=\"http://www.baidu.com\" onclick=\"alert('哎呀,我被点了'); return false\"&gt;百度&lt;/a&gt; &lt;!--方法3：注意这里哦，这里调用f1的函数，返回的是一个false，所以这里要添加一个return--&gt; &lt;a href=\"http://www.baidu.com\" onclick=\"return f1()\"&gt;百度&lt;/a&gt; function f1() { alert(\"哇塞,好漂亮哦\"); return false; } 案例15：鼠标进入onmouseover、离开onmouseout改变标签的背景颜色 //获取所有的li标签 var list = document.getElementsByTagName(\"li\"); for (var i = 0; i &lt; list.length; i++) { //为li注册鼠标进入事件 list[i].onmouseover = function () { this.style.backgroundColor = \"yellow\"; }; //为li注册鼠标离开事件 list[i].onmouseout = function () { //恢复到这个标签默认的颜色 this.style.backgroundColor = \"\"; }; } 注意技巧4： getElementsByTagName获取的是数组，如果只使用一个，就要加序号getElementsByTagName(\"li\")[0] 设置元素的样式的方式： &lt;p&gt;​ 1. &lt;strong&gt;对象 ** . style . **属性 **= **值&lt;/strong&gt;；&lt;/p&gt; &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2. **对象** . className = **值**； 对象.className=“”使用的时候要注意，若只写想要设置的类名，会覆盖这个对象所有的类。 案例17：点击按钮，修改div的宽、高、背景颜色 &lt;input type=\"button\" value=\"设置样式\" id=\"btn\"/&gt; &lt;div id=\"dv\"&gt;&lt;/div&gt; //方法一：直接修改样式 .style.属性 = 值； document.getElementById$(\"btn\").onclick = function () { document.getElementById(\"dv\").style.width = \"300px\"; document.getElementById(\"dv\").style.height = \"200px\"; document.getElementById(\"dv\").style.backgroundColor = \"pink\"; //原来在css中是background-color }; /*方法二：通过给元素添加css样式属性 .className = 值； */ .cls {width: 300px;height: 200px;background-color: yellow;border: 2px solid red;} my$(\"btn\").onclick = function () { //在js代码中DOM操作的时候,设置元素的类样式,不用class关键字,应该使用,className my$(\"dv\").className=\"cls\"; //等价于：&lt;div id=\"dv\" class=“cls”/cls&gt;&lt;/div&gt; }; 注意技巧5： 如果在 css 中属性是多个单词（带-）的写法，那么在js代码中DOM操作的时候，要用驼峰命名法来调用 案例18：获取焦点onfocus，失去焦点事件onblur my$(\"txt\").onfocus = function () { //判断文本框的内容是不是默认的内容 if (this.value == \"请输入搜索内容\") { this.value = \"\";//清空文本框 this.style.color = \"black\"; } }; my$(\"txt\").onblur = function () { //1.判断字符串方式 if (this.value == \"\") { this.value = \"请输入搜索内容\"; this.style.color = \"gray\"; } //2.判断字符串长度方式，更推荐这种，数字判断的运行效率高 if (this.value.length == 0) { this.value = \"请输入搜索内容\"; this.style.color = \"gray\"; } }; 注意技巧6： 如果这个属性在浏览器中不支持，那么这个属性的类型是undefined。 案例19：自定义属性 设置自定义属性：setAttribute(\"属性的名字\",\"属性的值\"); 获取自定义属性的值：getAttribute(\"属性的名字\"); 移除义属性：removeAttribute(\"属性的名字\"); &lt;ul id=\"uu\"&gt; &lt;li&gt;数学成绩&lt;/li&gt; &lt;li&gt;英语成绩&lt;/li&gt; &lt;li&gt;语文成绩&lt;/li&gt; &lt;li&gt;科学成绩&lt;/li&gt; &lt;li&gt;历史成绩&lt;/li&gt; &lt;/ul&gt; var list=my$(\"uu\").getElementsByTagName(\"li\");//根据id获取ul标签,并且或者该标签中所有的li //为每个li添加自定义属性 for(var i=0;i&lt;list.length;i++){//循环遍历 list[i].setAttribute(\"score\",(i+1)*10);//添加在DOM对象上,不在标签中 list[i].onclick=function(){//点击每个li标签,获取对应的自定义属性值 alert(this.getAttribute(\"score\")); }; } //移除自定义属性 document.getElementById(\"btn\").onclick=function () { document.getElementById(\"dv\").removeAttribute(\"score\");//移除自定义属性，没值也没属性 document.getElementById(\"dv\").className=\"\";//移除元素的类样式，值没有了,但是属性还是有的 document.getElementById(\"dv\").removeAttribute(\"class\");//移除自定义属性，没值也没属性 }; 案例20：获取标签的内容 分类 名称 说明 使用时的区别 属性 innerHTML 设置或返回元素开始和结束标签之间的 HTML 保持编写的格式、样式标签&lt;&gt; 属性 innerText 设置或返回元素中去除所有标签的内容 去掉所有格式以及标签的纯文本内容 属性 textContent 设置或返回指定节点的文本内容 去掉标签后，保留文本样式，有回车 方法 document.write() 向文档写入指定的内容 方法 document.writeln() 向文档写入指定的内容并换行 &lt;hr style=&quot;visibility: hidden;&quot;&gt; &lt;ul class=&quot;pager&quot;&gt; &lt;li class=&quot;previous&quot;&gt; &lt;a href=&quot;/2019/06/21/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;内置对象和基本包装类型&quot;&gt; Previous&lt;br&gt; &lt;span&gt;内置对象和基本包装类型&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;next&quot;&gt; &lt;a href=&quot;/2019/06/25/Vue2.0%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;Vue2.0官方文档 知识点总结1&quot;&gt; Next&lt;br&gt; &lt;span&gt;Vue2.0官方文档 知识点总结1&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!--Gitalk评论start --&gt; &lt;!-- Gitalk end --&gt; &lt;/div&gt; &lt;!-- Side Catalog Container --&gt; &lt;div class=&quot; col-lg-2 col-lg-offset-0 visible-lg-block sidebar-container catalog-container&quot;&gt; &lt;div class=&quot;side-catalog&quot;&gt; &lt;hr class=&quot;hidden-sm hidden-xs&quot;&gt; &lt;h5&gt; &lt;a class=&quot;catalog-toggle&quot; href=&quot;#&quot;&gt;CATALOG&lt;/a&gt; &lt;/h5&gt; &lt;ul class=&quot;catalog-body&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Sidebar Container --&gt; &lt;div class=&quot; col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container&quot;&gt; &lt;!-- Featured Tags --&gt; &lt;section&gt; &lt;hr class=&quot;hidden-sm hidden-xs&quot;&gt; &lt;h5&gt;&lt;a href=&quot;/tags/&quot;&gt;FEATURED TAGS&lt;/a&gt;&lt;/h5&gt; &lt;div class=&quot;tags&quot;&gt; &lt;a href=&quot;/tags/#《JavaScript高级程序设计》&quot; title=&quot;《JavaScript高级程序设计》&quot; rel=&quot;6&quot;&gt; 《JavaScript高级程序设计》 &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 黑马视频 &gt;知识点&quot; title=&quot;&lt; 黑马视频 &gt;知识点&quot; rel=&quot;10&quot;&gt; &lt; 黑马视频 &gt;知识点 &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; Vue2.0官方文档 &gt; 知识点&quot; title=&quot;&lt; Vue2.0官方文档 &gt; 知识点&quot; rel=&quot;2&quot;&gt; &lt; Vue2.0官方文档 &gt; 知识点 &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 面试题整理 &gt;&quot; title=&quot;&lt; 面试题整理 &gt;&quot; rel=&quot;6&quot;&gt; &lt; 面试题整理 &gt; &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 算法题 &gt;&quot; title=&quot;&lt; 算法题 &gt;&quot; rel=&quot;2&quot;&gt; &lt; 算法题 &gt; &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 工作遇到的问题记录 &gt;&quot; title=&quot;&lt; 工作遇到的问题记录 &gt;&quot; rel=&quot;11&quot;&gt; &lt; 工作遇到的问题记录 &gt; &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 微信小程序的学习 &gt;&quot; title=&quot;&lt; 微信小程序的学习 &gt;&quot; rel=&quot;2&quot;&gt; &lt; 微信小程序的学习 &gt; &lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;!-- Friends Blog --&gt; &lt;hr&gt; &lt;h5&gt;FRIENDS&lt;/h5&gt; &lt;ul class=&quot;list-inline&quot;&gt; &lt;li&gt;&lt;a href=&quot;https://juejin.im/&quot;&gt;掘金&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/&quot;&gt;SegmentFault&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.v2ex.com/&quot;&gt;V2EX&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://readhub.cn/&quot;&gt;Readhub&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/&quot;&gt;OSCHINA&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://toutiao.io/posts/hot/7&quot;&gt;开发者头条&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; function async(u, c) { var d = document, t = 'script', o = d.createElement(t), s = d.getElementsByTagName(t)[0]; o.src = u; if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); } s.parentNode.insertBefore(o, s); } async(\"//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js\",function(){ anchors.options = { visible: 'always', placement: 'right', icon: '#' }; anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5'); }) /* place left on bigger screen */ @media all and (min-width: 800px) { .anchorjs-link{ position: absolute; left: -0.75em; font-size: 1.1em; margin-top : -0.1em; } } ', methods:{ //定义点击的时候向外触发一个delete事件，同时传入数组下标 handleItemClick:function(){ this.$emit('delete',this.index)//向外触发一个事件 } } } var app = new Vue({ //定义这个Vue实例场控的范围 el : '#app', // 局部变量声明之后要在父组件中添加声明，才能使用 components:{ TodoItem:TodoItem }, data : { list : [], inputValue:'' }, methods:{ //定义的是绑定在input上面的点击事件，每提交一次都会触发在list中添加用户输入的内容，添加过后清空输入框，使用的是v-model这个进行数据的双向绑定 handleBtnClick:function(){ this.list.push(this.inputValue) this.inputValue='' }, handleItemDelete:function(index){ this.list.splice(index,1) } } }) vue实例的生命周期 Vue的生命周期就是Vue实例在某一个时间点会自动执行的函数 Vue的生命周期函数并不会放在methods里面进行定义，而是直接放在实例对象里面就可以了 var vm = new Vue({ el:&apos;#app&apos;, data:{ test:&apos;hello world&apos; }, template:&apos;&lt;div&gt; &lt;/div&gt;&apos;, beforeCreate:function(){ console.log(&apos;beforeCreate&apos;) }, created:function(){ console.log(&apos;created&apos;) }, beforeMount:function(){//渲染前 console.log(this.$el);//没有输出内容 console.log(&apos;beforeMount&apos;); }, mounted:function(){//渲染后 console.log(this.$el); //可以输出&lt;div&gt;&apos;hello world&apos;&lt;/div&gt; console.log(&apos;mounted&apos;); }, beforeDestroy:function(){ console.log(&apos;beforeDestroy&apos;) }, destroyed:function(){ console.log(&apos;destroy&apos;) }, //数据改变之前 beforeUpdate:function(){ console.log(&apos;beforeUpate&apos;) }, //数据改变渲染之后 updated:function(){ console.log(&apos;updated&apos;) } })vue的模板语法第一种：插值表达式 ``；第二种： v-text 将标签中innerTxet的内容变成表达式代表的data中的内容，若有标签，会进行转义后输出；第三种 ： v-html 除了可以正常显示内容以外，遇到标签还会进行解析 。还有很多，例如v-on/@、v-bind/:等 &lt;div v-text=&apos;name + &quot;Lee&quot;&apos;&gt;&lt;/div&gt; &lt;div v-html=&apos;name + &quot;Lee&quot;&apos;&gt;&lt;/div&gt;当vue指令后面跟了一个值的时候，说明后面跟的不是字符串而是一个js的表达式 总结：这三种有什么不同呢? 共同点：都可以添加写js表达式”Lee”；区别：插值表达式和v-text功能是一样的，不会解析标签；v-html是可以解析标签的注意，当vue指令后面跟了一个值的时候，这个值就不再是字符串了 ，而是一个js表达式； 计算属性和侦听器第一种方法：计算属性computed特点：内置缓存，计算属性依赖的值不变化，它就不会重新计算； 当依赖的值发生了变化，就会重新计算一次； var vm = new Vue({ el: \"#app\", data: { firstName: 'Dell', lastName: 'Alice', fullName: \"Dell Alice\", age: 39 }, computed: { fullName: function () { console.log('computed'); return this.firstName + \" \" + this.lastName } } }) 第二种：方法methods，不如计算属性好 缺点： 没有缓存机制，如果改变了页面中别的值，页面重新渲染一次，这个方法就执行一次； 在DOM结构中使用methods方法，要在方法后面加括号进行调用； var vm = new Vue({ el: \"#app\", data: { firstName: 'Dell', lastName: 'Alice', fullName: \"Dell Alice\", age: 39 }, methods:{ 第三种：侦听器watch 特点：和计算属性很类似，会有缓存，依赖的变量不发生改变就不会重新计算； watch 和 computed 语法对比，功能相似，但是computed的语法更加简单； var vm = new Vue({ el: \"#app\", data: { firstName: 'Dell', lastName: 'Alice', fullName: \"Dell Alice\", age: 39 }, watch: { firstName: function () { console.log('计算了一次'); this.fullName = this.firstName + \" \" + this.lastName; }, lastName: function () { console.log('计算了一次'); this.fullName = this.firstName + \" \" + this.lastName; } } }) 计算属性的setter和getter 取输入的值的时候，运行get方法；当设置值的时候，set执行。 var vm = new Vue({ el:'#app', data:{ firstName:'Dell', lastName:'Alice' }, // computed的特性是当它依赖的值变化的时候会进行重新计算 computed :{ fullName:{ get : function() { return this.firstName + ' ' + this.lastName // 写的时候不要漏写return以及this }, set : function(value){ //value参数可以获取到外部数据 var arr = value.split(\" \"); this.firstName = arr[0]; this.lastName = arr[1]; } } } }) 样式绑定 第一种方法：class 的对象绑定方式 :class=”{activated:isActivated} .activated {color: red;} hello world var vm = new Vue({ el: \"#app\", data: { isActivated: false }, // 第一种方法：class的对象绑定,绑定点击事件,事件改变class是否显示 methods: { handleDivClick: function () { this.isActivated = !this.isActivated; } } }) 第二种方法：class的数组绑定 :class=”[activated,activatedOne]” class可以和一个数组绑定，数组里面写的内容代表的是一个变量； **class绑定的是数组里面的内容：class:”[activated]”显示的是activated中的内容 **。 hello world var vm = new Vue({ el: \"#app1\", data: { activated: '',//默认为空 activatedOne: 'activated-one' }, methods: { handleDivClick: function () { //如果class有样式属性,那么赋值为‘’空;如果没有,就给这个标签样式属性 this.activated = this.activated === &quot;activated&quot; ? &apos;&apos; : &quot;activated&quot; } } })第三种方法：内联样式 style1.对象绑定方式 :style=’styleObj’ &lt;div :style=’styleObj’ @click=’handleDivClick’&gt; hello world var vm = new Vue({ el: ‘#app2’, data: { styleObj: { color: ‘black’ } }, methods: { handleDivClick: function () { this.styleObj.color = this.styleObj.color === “black” ? ‘red’ : “black”; } }}) 2.数组绑定方式 :style=’[styleObj,{fontSize:”20px”}]’ hello world var vm = new Vue({ el: '#app3', data: { styleObj: { color: 'black' } }, methods: { handleDivClick: function () { this.styleObj.color = this.styleObj.color === 'black' ? \"red\" : 'black' } } }) 注意：写内联样式的时候，不要写font-size，要写fontSize 条件渲染 v-if v-show通过一个 v-if 和 v-show 的指令,结合js的表达式,决定一个标签是否在页面上展示； var vm = new Vue({ el:'#app1', data:{ show:false, message:'Hello World' } }) 比较v-if和v-show 共同点：两者都可以控制一个模板标签是否在页面上显示； 不同点：v-if定义的标签，只要值是false，就不会存在于DOM结构之上； ​ v-show定义的标签值是false的时候,仍存在DOM上,只是display:none了； 在具体使用的时候,会更多用到v-show，不会频繁操作DOM树,性能相对高一些 。 条件表达式更加复杂的用法使用v-if和v-else的时候，要紧贴在一起使用，若中间有别的标签，那么页面就会报错，就无法解析。 &lt;div id=&quot;app2&quot;&gt; &lt;div v-if=&apos;show&apos;&gt;&lt;/div&gt; &lt;div v-else&gt;Bye World&lt;/div&gt; &lt;div v-if=&apos;show1 === &quot;a&quot;&apos;&gt;This is A&lt;/div&gt; &lt;div v-else-if=&apos;show1 ===&quot;b&quot; &apos;&gt;This is B&lt;/div&gt; &lt;div v-else&gt;This is others &lt;/div&gt; &lt;/div&gt; var vm = new Vue({ el:&apos;#app2&apos;, data:{ show1:&apos;a&apos;, show:false, message:&apos;hello world&apos; } })条件渲染中key值的使用为什么要使用key值：因为在改变show后,页面进行重新渲染时,会尽量复用页面上的DOM，导致已经输入的用户名的input没有清空并继续作为邮箱的input使用；为某个标签添加key值(名字任意)之后，Vue会知道是页面唯一的元素，两个key值不一样， Vue就不会尝试复用这个标签。 &lt;div id=&quot;app3&quot;&gt; &lt;div v-if=&apos;show2&apos; &gt; 用户名&lt;input key=&apos;username&apos;/&gt; &lt;/div&gt; &lt;div v-else&gt; 邮箱&lt;input key=&apos;passwaord&apos; /&gt; &lt;/div&gt; &lt;/div&gt; var vm =new Vue({ el:&apos;#app3&apos;, data:{ show3:false, } })列表渲染part1：数组循环 为了提升循环显示的性能，会给每个循环项上加一个唯一的key值， 这里不是很推荐写inedx值，会频繁造作DOM元素相对应的数据，废性能,可能会导致Vue没有办法充分复用节点，一般项目中除了内容还会返回id，使用这个id作为标识`:key=’item.id’ 当我们为数组增加内容的时候，不能使用数组的下标形式添加/改变数组 ( 这种方法虽然会改变数据，但是页面不会响应 ) 第一种响应式改变数组数据的方法：我们只能通过vue提供的7个数组变异方法来操作数组，才能够实现数据发生变化，页面也跟着变化这种响应式的方法：push增加最后一项、pop删除最后一项、shift删除第一项 、unshift添加第一项、 splice(1开始下标,1个数,添加的内容)数组的截取 、sort数组排序、 reverse数组取反； 第二种响应式改变数组数据的方法：改变数组内容并响应的方法，就是“改变引用”，直接修改引用的list，让它指向另一个数组的地址 第三种set方法：第二个参数代表了数组的下标，第三个是改变的内容 Vue.set方法[全局方法]：Vue.set（vm.userInfo , 2 , “beijing”） vm.$set方法[实力方法]：vm.$set（vm.userInfo , 2, “beijing”） 当我们要遍历两个标签，但是又不想用div标签来包裹这两个标签循环的时候，可以使用template模板占位符，在渲染的过程中并不会真正得被渲染到页面上 --- &lt;/span&gt; &lt;/template&gt; var vm = new Vue({ el: '#app', data: { list: [ { id: '5646465', text: 'nihao' }, { id: '45645646', text: 'how' }, { id: '54687', text: 'you' } ] } }) part2：除了数组，对象也可以进行循环 item是键值,key是键名,index是索引这里直接修改键值，页面是可以做到响应的，但是如果是添加一个键值对，就会发现只改变了数值，页面没有进行响应式改变；这个时候使用改变指向，直接重新赋值userInfo这个对象的所有值。Vue.set方法[全局方法]：Vue.set（vm.userInfo , “adress” , “beijing”）vm.$set方法[实力方法]：vm.$set（vm.userInfo , “adress” , “beijing”） ——- var vm = new Vue({ el:’#app1’, data:{ userInfo:{ name:’Alice’, age:28, gender:’female’, salary:’zero’ } } })is属性解决模板标签的bug情况h5的规范里面，table里面一定要有tdoby，tbody里面一定要有tr，如果用row组件代替tr使用就会报错，同理还有里面都要放标签;标签里面要放。 解决方法：，相当于调用了row这个组件 子组件中data的定义要用返回函数data在根组件里面可以直接定义，但是在子组件中定义data时，要求必须是一个函数，返回所对应的数据内容。 原因：子组件会被调用很多次，每一个子组件的数据之间最好没有冲突，每个子组件都有自己的数据；通过函数返回一个数据对象的目的，就是为了让每个子组件都拥有一个独立的数据存储，不会出现多个子组件之间互相影响的情况。 Vue.component(‘row’, { template: ‘ header.intro-header{ position: relative; background-image: url('/img/home.jpg') } &lt;a class=&quot;tag&quot; href=&quot;/tags/#&lt; 黑马视频 &gt;知识点&quot; title=&quot;&lt; 黑马视频 &gt;知识点&quot;&gt;&lt; 黑马视频 &gt;知识点&lt;/a&gt; &lt;/div&gt; &lt;h1&gt;DOM相关知识点整理1&lt;/h1&gt; &lt;h2 class=&quot;subheading&quot;&gt;&lt;/h2&gt; &lt;span class=&quot;meta&quot;&gt;Posted by CodingWithAlice on June 23, 2019&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Post Container --&gt; &lt;div class=&quot; col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container&quot;&gt; &lt;h3 id=&quot;本文概要如下&quot;&gt;本文概要如下：&lt;/h3&gt; DOM树：把html页面或者是xml文件看成是一个文档，文档就是一个对象，这个文档中所有的标签都是元素，元素也可以看成是对象,标签(元素，对象)有很多，还有嵌套的关系,组成的这种层次结构，可以模拟成树形结构图，简称：树状图，就是DOM树。 DOM对象：通过DOM方式获取的元素得到的对象 获取元素多种方式： 根据 id属性 的值获取元素，返回来的是一个元素对象； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.getElementById(&quot;id属性的值&quot;);&lt;/code&gt;&lt;/p&gt; 根据 标签名字 获取元素，返回来的是一个伪数组，返回具有指定标签名的元素子元素集合；document.getElementsByTagName(\"标签名字\"); &lt;p&gt;&lt;strong&gt;下面的几个,有的浏览器不支持(ie8)&lt;/strong&gt;&lt;/p&gt; 根据 name属性 的值获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.getElementsByName(&quot;name属性的值&quot;)&lt;/code&gt;&lt;/p&gt; 根据 类样式 的名字来获取元素，返回来的是一个伪数组，里面保存了多个的DOM对象； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.getElementsByClassName(&quot;类样式的名字&quot;)&lt;/code&gt;&lt;/p&gt; 根据 选择器 获取元素，返回来的是一个元素对象，文档中匹配到指定的元素的第一个对象； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.querySelector(&quot;选择器的名字#btn&quot;); &lt;/code&gt;&lt;/p&gt; 根据 选择器 获取元素，返回来的是一个伪数组，文档中匹配到指定的元素的对象集合； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.querySelectorAll(&quot;选择器的名字.cls&quot;) &lt;/code&gt;&lt;/p&gt; 获取boby、title、html标签 console.log(document.body); //获取的是元素--标签 console.log(document.title); //标签中的值 console.log(document.documentElement);//获取根元素html 操作基本标签的属性 src,title,alt,href,id属性 操作表单标签的属性吧+21 name,value,type,checked,selected,disabled,readonly 元素的样式操作 对象.style.属性=值; 对象.className=值; 为元素添加事件的操作：有事件源，触发和响应； 例如：按钮被点击,弹出对话框 其中：按钮—-&gt;事件源 点击—-&gt;事件名字 被点了—&gt;触发了 弹框了—&gt;响应 this的指向改变方法： 使用ES6的箭头函数，this在定义的时候被指定； 在函数内部使用_this=this;来保存this的指向； 使用apply()、call()、bind()； new实例化一个对象，this指向新对象； 接下来是详细分析介绍： DOM经常进行的操作： ​ • 获取元素 ​ • 动态创建元素 ​ • 对元素进行操作(设置其属性或调用其方法) ​ • 事件(什么时机做相应的操作) &lt;input type=\"button\" value=\"弹框\" onclick=\"alert('哈哈,我又变帅了')\" /&gt; 等价于 &lt;input type=\"button\" value=\"显示效果\" id=\"btn\"/&gt; //document.getElementById(\"id属性的值\");返回的是一个元素对象 document.getElementById(\"btn\").onclick=function () { alert(\"哈哈,我又变帅了\"); }; 等价于 var btnObj=document.getElementById(\"btn\"); btnObj.onclick=function(){ alert(\"这是分成两行代码的方式\"); } HTML：展示信息，展示数据的 XML：侧重于存储数据 根元素:html标签 元素(element)：页面中的所有的标签都是元素，元素可以看成是对象 文档 document：一个网页可以称为文档；页面中的顶级对象； 节点 Node：网页中的所有内容都是节点（标签、属性、文本[文字、换行、空格、回车]、注释等） 节点的属性：标签的属性；作用：为了将来获取很多节点，得到节点中的标签（元素），识别节点中的标签元素 点击事件：如下以案例举例出现的情况以及其功能 案例1：点击按钮显示图片：点击按钮的时候设置img标签的src属性有一个图片的路径 &lt;input type=\"button\" value=\"显示图片\" id=\"btn\"/&gt; &lt;img src=\"\" alt=\"\" id=\"im\" /&gt; var btnObj=document.getElementById(\"btn\"); //为按钮注册点击事件,添加事件处理函数 btnObj.onclick=function () { var imObj=document.getElementById(\"im\"); imObj.src=\"images/liuyan.jpg\"; imObj.width=\"300\"; imObj.height=\"400\"; }; 案例2：点击按钮，修改p标签的显示内容 &lt;input type=\"button\" value=\"设置p的内容\" id=\"btn\"/&gt; &lt;p id=\"p1\"&gt;我是一个p标签&lt;/p&gt; //根据id获取按钮,为按钮注册点击事件,添加事件处理函数 document.getElementById(\"btn\").onclick=function () { //根据id获取p标签,设置内容 document.getElementById(\"p1\").innerText=\"这是一个p\"; }; 注意技巧1： 凡是成对的标签,中间的文本内容,设置的时候,都使用 innerText 这个属性的方式； 案例3：点击按钮修改a标签的地址和热点文字 &lt;input type=\"button\" value=\"显示效果\" id=\"btn\"/&gt; &lt;a id=\"ak\" href=\"https://www.jiumodiary.com/\"&gt;鸠摩搜书&lt;/a&gt; //注册点击事件,添加事件处理函数 document.getElementById(\"btn\").onclick = function () { //设置href属性 document.getElementById(\"ak\").href = \"https://codingwithalice.github.io/\"; //设置文字内容 document.getElementById(\"ak\").innerText = \"CodingWithAlice\"; }; 可对javascript代码进行优化： //上面的代码，获取了两次id为ak的元素，增加了浏览器的负担。 //优化后的: document.getElementById(\"btn\").onclick = function () { //设置href属性，设置文字内容 var aObj = document.getElementById(\"ak\"); aObj.href = \"https://codingwithalice.github.io/\"; aObj.innerText = \"CodingWithAlice\"; }; 案例4：点击按钮设置多个p标签的文字内容 &lt;input type=\"button\" value=\"显示效果\" id=\"btn\"/&gt; &lt;div id=\"dv1\"&gt; &lt;p&gt;CtrlCoder&lt;/p&gt; &lt;p&gt;CtrlCoder&lt;/p&gt; &lt;/div&gt; &lt;div id=\"dv2\"&gt; &lt;p&gt;CodingWithAlice&lt;/p&gt; &lt;p&gt;CodingWithAlice&lt;/p&gt; &lt;p&gt;CodingWithAlice&lt;/p&gt; &lt;/div&gt; document.getElementById(\"btn\").onclick=function () { //根据标签名字获取标签,返回的是一个伪数组 var pObjs= document.getElementsByTagName(\"p\"); //循环遍历这个数组 for(var i=0;i&lt;pObjs.length;i++){ //每个p标签,设置文字 pObjs[i].innerText=\"我们都是p\"; } }; 案例5：点击按钮改变图片的alt和titile &lt;input type=\"button\" value=\"显示效果\" id=\"btn\"/&gt; &lt;img src=\"images/cangjingkong.jpg\" alt=\"CtrlCoder\" title=\"CodingWithAlice\"/&gt; document.getElementById(\"btn\").onclick = function () { //没有给img id名称，可以用tagname获取，但是一定要注意返回的是一个伪数组 var imgObjs = document.getElementsByTagName(\"img\"); imgObjs[0].alt = \"改了\";//调用的时候以数组的形式调用 imgObjs[0].title = \"实现吧\"; }; 案例6：点击按钮修改文本框的值 &lt;input type=\"button\" value=\"修改文本框的值\" id=\"btn\"/&gt;&lt;br/&gt; &lt;input type=\"text\" value=\"\"/&gt;&lt;br/&gt; &lt;input type=\"text\" value=\"\"/&gt;&lt;br/&gt; &lt;input type=\"text\" value=\"\"/&gt;&lt;br/&gt; &lt;input type=\"text\" value=\"\"/&gt;&lt;br/&gt; document.getElementById(\"btn\").onclick = function () { //获取所有的文本框，包含了第一个type为button var inputs = document.getElementsByTagName(\"input\"); for (var i = 0; i &lt; inputs.length; i++) { //用该元素的type属性判断这个元素是不是按钮 if (inputs[i].type != \"button\") { inputs[i].value = \"CodingWithAlice\"; } } }; 案例7：显示与隐藏 &lt;style&gt; div{ width: 300px; height: 200px; background-color: darkmagenta; } &lt;/style&gt; &lt;input type=\"button\" value=\"隐藏\" id=\"btn\"/&gt; &lt;input type=\"button\" value=\"显示\" id=\"btn2\"/&gt; &lt;div id=\"dv\"&gt;&lt;/div&gt; document.getElementById(\"btn\").onclick=function () { document.getElementById(\"dv\").style.display=\"none\"; }; document.getElementById(\"btn2\").onclick=function () { document.getElementById(\"dv\").style.display=\"block\"; }; 案例7：显示与隐藏优化：一个按钮的写法 &lt;style&gt; div{ width: 300px; height: 200px; background-color: darkmagenta; } .cls { display: none; } &lt;/style&gt; &lt;input type=\"button\" value=\"隐藏\" id=\"btn\"/&gt; &lt;div id=\"dv\"&gt;&lt;/div&gt; //点击按钮,通过类样式的方式设置div的显示和隐藏 document.getElementById(\"btn\").onclick = function () { //判断的是div是否应用了类样式 if (document.getElementById(\"dv\").className != \"cls\") { //没有应用类样式，现在是显示的,应该隐藏 document.getElementById(\"dv\").className = \"cls\"; //执行完上一句，就隐藏了，按钮改变 this.value = \"显示\"; } else { document.getElementById(\"dv\").className = \"\"; //执行完上一句，就显示了，按钮改变 this.value = \"隐藏\"; } }; 案例8：开关灯，body标签背景颜色 &lt;style&gt; .cls {background-color: black;} &lt;/style&gt; &lt;input type=\"button\" value=\"开/关灯\" id=\"btn\"/&gt; document.getElementById(\"btn\").onclick = function () { document.body.className = document.body.className != \"cls\" ? \"cls\" : \"\"; }; 案例9：单选和多选和下拉菜单 //单选 &lt;input type=\"button\" value=\"修改性别\" id=\"btn1\"/&gt; &lt;input type=\"radio\" value=\"1\" name=\"sex\"/&gt;男 &lt;input type=\"radio\" value=\"2\" name=\"sex\" id=\"rad1\"/&gt;女 &lt;input type=\"radio\" value=\"3\" name=\"sex\"/&gt;保密 document.getElementById(\"btn1\").onclick = function () { document.getElementById(\"rad1\").checked = true; }; 注意技巧2： 在表单标签中,如果属性和值只有一个，并且值是这个属性本身，那么在写js代码，DOM操作的时候，这个属性值，是布尔类型就可以了。 //多选 &lt;input type=\"button\" value=\"选择兴趣\" id=\"btn2\"/&gt; &lt;input type=\"checkbox\" value=\"1\" name=\"xingqu\" /&gt;吃饭 &lt;input type=\"checkbox\" value=\"2\" name=\"xingqu\" id=\"ck1\" /&gt;睡觉 &lt;input type=\"checkbox\" value=\"3\" name=\"xingqu\" id=\"ck2\" /&gt;打豆豆 document.getElementById(\"btn2\").onclick=function () { document.getElementById(\"ck1\").checked=true; document.getElementById(\"ck2\").checked=true; }; //下拉菜单 &lt;input type=\"button\" value=\"点菜\" id=\"btn\"/&gt; &lt;select name=\"\" id=\"ss\"&gt; &lt;option value=\"1\"&gt;油炸榴莲&lt;/option&gt; &lt;option value=\"2\"&gt;爆炒臭豆腐&lt;/option&gt; &lt;option value=\"3\"&gt;清蒸助教&lt;/option&gt; &lt;option value=\"4\" id=\"op1\"&gt;凉拌班主任&lt;/option&gt; &lt;option value=\"5\"&gt;红烧小苏&lt;/option&gt; &lt;/select&gt; document.getElementById(\"btn\").onclick=function () { //点击按钮选择菜 document.getElementById(\"op1\").selected=true; }; 案例10：改变文本域内的值 &lt;textarea name=\"\" id=\"tt\" cols=\"30\" rows=\"10\" readonly=\"readonly\"/disabled=“disabled”/readonly/disabled &gt; 注册用户的协议:某人问智者,大师:您觉得怎么做才是最快乐的?回答说:不要和愚者辩论这个人说:我不这么认为!大师说:您说的对. &lt;/textarea&gt; &lt;input type=\"button\" value=\"注册\" id=\"btn2\"/&gt; document.getElementById(\"btn2\").onclick=function () { //推荐使用value，textarea是表单标签。 document.getElementById(\"tt\").value=\"CodingWithAlice\"; //document.getElementById(\"tt\").innerText=\"哈哈\"; }; 案例11：点击小图(保留),显示大图 &lt;a href=\"images/1.jpg\" id=\"ak\"&gt; &lt;img src=\"images/1-small.jpg\" alt=\"\"&gt; &lt;/a&gt; &lt;img src=\"\" alt=\"\" id=\"big\"&gt; //保证小图的保留 //点击小图,下面显示大图 //点击超链接触发事件 document.getElementById(\"ak\").onclick=function () { document.getElementById(\"big\").src=this.href; return false;//保证小图的保留 }; 相册操作： &lt;ul id=\"imagegallery\"&gt; &lt;li&gt; &lt;a href=\"images/1.jpg\" title=\"A\"&gt; &lt;img src=\"images/1-small.jpg\" width=\"100\" alt=\"1\"/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/2.jpg\" title=\"B\"&gt; &lt;img src=\"images/2-small.jpg\" width=\"100\" alt=\"2\"/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/3.jpg\" title=\"C\"&gt; &lt;img src=\"images/3-small.jpg\" width=\"100\" alt=\"3\"/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/4.jpg\" title=\"D\"&gt; &lt;img src=\"images/4-small.jpg\" width=\"100\" alt=\"4\"/&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;img id=\"image\" src=\"images/placeholder.png\" alt=\"\" width=\"450\"/&gt;//点击链接a后显示大图的标签 &lt;p id=\"des\"&gt;选择一个图片&lt;/p&gt; //第一步：点击a标签,把a标签中的href的属性值给id为image的src属性 //第二步：把a的title属性的值给id为des的p标签赋值 var aObjs=document.getElementById(\"imagegallery\").getElementsByTagName(\"a\"); //循环遍历所有的a标签 for(var i=0;i&lt;aObjs.length;i++){ //为每个a标签注册点击事件 aObjs[i].onclick=function () { document.getElementById(\"image\").src=this.href; document.getElementById(\"des\").innerText=this.title; //阻止超链接默认的跳转 return false; }; } 案例12：隔行变色，奇红偶黄 &lt;input type=\"button\" value=\"隔行变色\" id=\"btn\"/&gt; &lt;ul id=\"uu\"&gt; &lt;li&gt;红旗&lt;/li&gt; &lt;li&gt;五菱宏光&lt;/li&gt; &lt;li&gt;奔驰&lt;/li&gt; &lt;li&gt;兰博基尼&lt;/li&gt; &lt;li&gt;哈弗&lt;/li&gt; &lt;/ul&gt; //第一种方法 document.getElementById(\"btn\").onclick=function () { //获取所有的li标签 var list=document.getElementById(\"uu\").getElementsByTagName(\"li\"); for(var i=0;i&lt;list.length;i++){ if(i%2==0){ list[i].style.backgroundColor=\"red\"; }else{ list[i].style.backgroundColor=\"yellow\"; } } }; //第二种方法：简写，善于利用三元表达式 document.getElementById(\"btn\").onclick = function () { //获取所有的li标签 var list = document.getElementById(\"uu\").getElementsByTagName(\"li\"); for (var i = 0; i &lt; list.length; i++) { list[i].style.backgroundColor = i % 2 == 0 ? \"red\" : \"yellow\"; } }; 案例13：排他功能 &lt;input type=\"button\" value=\"没怀孕\"/&gt; &lt;input type=\"button\" value=\"没怀孕\"/&gt; &lt;input type=\"button\" value=\"没怀孕\"/&gt; var btnObjs = document.getElementsByTagName(\"input\"); for (var i = 0; i &lt; btnObjs.length; i++) { //每个事件包括两件事情 btnObjs[i].onclick = function () { //第一：把所有的按钮的value值设置为默认的值:没怀孕 for (var j = 0; j &lt; btnObjs.length; j++) { btnObjs[j].value = \"没怀孕\"; } //第二：当前被点击的按钮设置为:怀孕了 this.value = \"怀孕了\"; }; } 注意技巧3： 设置被点击按钮的时候，不能用btnObjs[i].value ，因为事件是在触发的时候执行的，而 for 循环是在页面加载的时候执行完毕了，触发时间的时候，i=btnObjs.length 案例14：阻止超链接跳转 &lt;a href=\"images/lb1.jpg\" id='a1'&gt;&lt;img src=\"images/content_bg.jpg\" alt=\"\" id='im'&gt;&lt;/a&gt; //方法1： document.getElementById('im').onclick=function(){ this.src=document.getElementById('a1').href; return false;//阻止链接默认跳转 } &lt;!--方法2：return flase 写在行内式中--&gt; &lt;a href=\"http://www.baidu.com\" onclick=\"alert('哎呀,我被点了'); return false\"&gt;百度&lt;/a&gt; &lt;!--方法3：注意这里哦，这里调用f1的函数，返回的是一个false，所以这里要添加一个return--&gt; &lt;a href=\"http://www.baidu.com\" onclick=\"return f1()\"&gt;百度&lt;/a&gt; function f1() { alert(\"哇塞,好漂亮哦\"); return false; } 案例15：鼠标进入onmouseover、离开onmouseout改变标签的背景颜色 //获取所有的li标签 var list = document.getElementsByTagName(\"li\"); for (var i = 0; i &lt; list.length; i++) { //为li注册鼠标进入事件 list[i].onmouseover = function () { this.style.backgroundColor = \"yellow\"; }; //为li注册鼠标离开事件 list[i].onmouseout = function () { //恢复到这个标签默认的颜色 this.style.backgroundColor = \"\"; }; } 注意技巧4： getElementsByTagName获取的是数组，如果只使用一个，就要加序号getElementsByTagName(\"li\")[0] 设置元素的样式的方式： &lt;p&gt;​ 1. &lt;strong&gt;对象 ** . style . **属性 **= **值&lt;/strong&gt;；&lt;/p&gt; &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2. **对象** . className = **值**； 对象.className=“”使用的时候要注意，若只写想要设置的类名，会覆盖这个对象所有的类。 案例17：点击按钮，修改div的宽、高、背景颜色 &lt;input type=\"button\" value=\"设置样式\" id=\"btn\"/&gt; &lt;div id=\"dv\"&gt;&lt;/div&gt; //方法一：直接修改样式 .style.属性 = 值； document.getElementById$(\"btn\").onclick = function () { document.getElementById(\"dv\").style.width = \"300px\"; document.getElementById(\"dv\").style.height = \"200px\"; document.getElementById(\"dv\").style.backgroundColor = \"pink\"; //原来在css中是background-color }; /*方法二：通过给元素添加css样式属性 .className = 值； */ .cls {width: 300px;height: 200px;background-color: yellow;border: 2px solid red;} my$(\"btn\").onclick = function () { //在js代码中DOM操作的时候,设置元素的类样式,不用class关键字,应该使用,className my$(\"dv\").className=\"cls\"; //等价于：&lt;div id=\"dv\" class=“cls”/cls&gt;&lt;/div&gt; }; 注意技巧5： 如果在 css 中属性是多个单词（带-）的写法，那么在js代码中DOM操作的时候，要用驼峰命名法来调用 案例18：获取焦点onfocus，失去焦点事件onblur my$(\"txt\").onfocus = function () { //判断文本框的内容是不是默认的内容 if (this.value == \"请输入搜索内容\") { this.value = \"\";//清空文本框 this.style.color = \"black\"; } }; my$(\"txt\").onblur = function () { //1.判断字符串方式 if (this.value == \"\") { this.value = \"请输入搜索内容\"; this.style.color = \"gray\"; } //2.判断字符串长度方式，更推荐这种，数字判断的运行效率高 if (this.value.length == 0) { this.value = \"请输入搜索内容\"; this.style.color = \"gray\"; } }; 注意技巧6： 如果这个属性在浏览器中不支持，那么这个属性的类型是undefined。 案例19：自定义属性 设置自定义属性：setAttribute(\"属性的名字\",\"属性的值\"); 获取自定义属性的值：getAttribute(\"属性的名字\"); 移除义属性：removeAttribute(\"属性的名字\"); &lt;ul id=\"uu\"&gt; &lt;li&gt;数学成绩&lt;/li&gt; &lt;li&gt;英语成绩&lt;/li&gt; &lt;li&gt;语文成绩&lt;/li&gt; &lt;li&gt;科学成绩&lt;/li&gt; &lt;li&gt;历史成绩&lt;/li&gt; &lt;/ul&gt; var list=my$(\"uu\").getElementsByTagName(\"li\");//根据id获取ul标签,并且或者该标签中所有的li //为每个li添加自定义属性 for(var i=0;i&lt;list.length;i++){//循环遍历 list[i].setAttribute(\"score\",(i+1)*10);//添加在DOM对象上,不在标签中 list[i].onclick=function(){//点击每个li标签,获取对应的自定义属性值 alert(this.getAttribute(\"score\")); }; } //移除自定义属性 document.getElementById(\"btn\").onclick=function () { document.getElementById(\"dv\").removeAttribute(\"score\");//移除自定义属性，没值也没属性 document.getElementById(\"dv\").className=\"\";//移除元素的类样式，值没有了,但是属性还是有的 document.getElementById(\"dv\").removeAttribute(\"class\");//移除自定义属性，没值也没属性 }; 案例20：获取标签的内容 分类 名称 说明 使用时的区别 属性 innerHTML 设置或返回元素开始和结束标签之间的 HTML 保持编写的格式、样式标签&lt;&gt; 属性 innerText 设置或返回元素中去除所有标签的内容 去掉所有格式以及标签的纯文本内容 属性 textContent 设置或返回指定节点的文本内容 去掉标签后，保留文本样式，有回车 方法 document.write() 向文档写入指定的内容 方法 document.writeln() 向文档写入指定的内容并换行 &lt;hr style=&quot;visibility: hidden;&quot;&gt; &lt;ul class=&quot;pager&quot;&gt; &lt;li class=&quot;previous&quot;&gt; &lt;a href=&quot;/2019/06/21/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;内置对象和基本包装类型&quot;&gt; Previous&lt;br&gt; &lt;span&gt;内置对象和基本包装类型&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;next&quot;&gt; &lt;a href=&quot;/2019/06/25/Vue2.0%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;Vue2.0官方文档 知识点总结1&quot;&gt; Next&lt;br&gt; &lt;span&gt;Vue2.0官方文档 知识点总结1&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!--Gitalk评论start --&gt; &lt;!-- Gitalk end --&gt; &lt;/div&gt; &lt;!-- Side Catalog Container --&gt; &lt;div class=&quot; col-lg-2 col-lg-offset-0 visible-lg-block sidebar-container catalog-container&quot;&gt; &lt;div class=&quot;side-catalog&quot;&gt; &lt;hr class=&quot;hidden-sm hidden-xs&quot;&gt; &lt;h5&gt; &lt;a class=&quot;catalog-toggle&quot; href=&quot;#&quot;&gt;CATALOG&lt;/a&gt; &lt;/h5&gt; &lt;ul class=&quot;catalog-body&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Sidebar Container --&gt; &lt;div class=&quot; col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container&quot;&gt; &lt;!-- Featured Tags --&gt; &lt;section&gt; &lt;hr class=&quot;hidden-sm hidden-xs&quot;&gt; &lt;h5&gt;&lt;a href=&quot;/tags/&quot;&gt;FEATURED TAGS&lt;/a&gt;&lt;/h5&gt; &lt;div class=&quot;tags&quot;&gt; &lt;a href=&quot;/tags/#《JavaScript高级程序设计》&quot; title=&quot;《JavaScript高级程序设计》&quot; rel=&quot;6&quot;&gt; 《JavaScript高级程序设计》 &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 黑马视频 &gt;知识点&quot; title=&quot;&lt; 黑马视频 &gt;知识点&quot; rel=&quot;10&quot;&gt; &lt; 黑马视频 &gt;知识点 &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; Vue2.0官方文档 &gt; 知识点&quot; title=&quot;&lt; Vue2.0官方文档 &gt; 知识点&quot; rel=&quot;2&quot;&gt; &lt; Vue2.0官方文档 &gt; 知识点 &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 面试题整理 &gt;&quot; title=&quot;&lt; 面试题整理 &gt;&quot; rel=&quot;6&quot;&gt; &lt; 面试题整理 &gt; &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 算法题 &gt;&quot; title=&quot;&lt; 算法题 &gt;&quot; rel=&quot;2&quot;&gt; &lt; 算法题 &gt; &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 工作遇到的问题记录 &gt;&quot; title=&quot;&lt; 工作遇到的问题记录 &gt;&quot; rel=&quot;11&quot;&gt; &lt; 工作遇到的问题记录 &gt; &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 微信小程序的学习 &gt;&quot; title=&quot;&lt; 微信小程序的学习 &gt;&quot; rel=&quot;2&quot;&gt; &lt; 微信小程序的学习 &gt; &lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;!-- Friends Blog --&gt; &lt;hr&gt; &lt;h5&gt;FRIENDS&lt;/h5&gt; &lt;ul class=&quot;list-inline&quot;&gt; &lt;li&gt;&lt;a href=&quot;https://juejin.im/&quot;&gt;掘金&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/&quot;&gt;SegmentFault&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.v2ex.com/&quot;&gt;V2EX&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://readhub.cn/&quot;&gt;Readhub&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/&quot;&gt;OSCHINA&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://toutiao.io/posts/hot/7&quot;&gt;开发者头条&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; function async(u, c) { var d = document, t = 'script', o = d.createElement(t), s = d.getElementsByTagName(t)[0]; o.src = u; if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); } s.parentNode.insertBefore(o, s); } async(\"//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js\",function(){ anchors.options = { visible: 'always', placement: 'right', icon: '#' }; anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5'); }) /* place left on bigger screen */ @media all and (min-width: 800px) { .anchorjs-link{ position: absolute; left: -0.75em; font-size: 1.1em; margin-top : -0.1em; } } ', data: function () { return { // 记得要写return content: 'this is a row' } } }) Vue之中如何操作DOM:ref 用ref进行引用命名，$refs是所有引用的名称，找到我们定义的 ‘ hello ’ 的ref，获取其中的内容。 在标签上面使用ref通过this.$refs.名字 获取到的是标签对应的DOM元素this.$refs.hello.innerHTML 在组件上面使用ref通过this.$refs.名字 获取到的是子组件的引用this.$refs.counter1.number &lt;div ref=&apos;hello&apos; @click=&apos;handleDivClick&apos; &gt; hello world &lt;/div&gt; var vm = new Vue({ el: &apos;#root&apos;, methods: { handleDivClick: function () { alert(this.$refs.hello.innerHTML)//获取到DOM元素中的内容 } } })案例：计数器 &lt;div id=&apos;root1&apos;&gt; &lt;counter ref=&apos;counter1&apos; @change=&apos;handleChange&apos;&gt;&lt;/counter&gt; &lt;counter ref=&apos;counter2&apos; @change=&apos;handleChange&apos;&gt;&lt;/counter&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; Vue.component(&apos;counter&apos;,{ template:&apos;&lt;div @click=&quot;handleClick&quot;&gt;&lt;/div&gt;&apos;, data:function(){ return{ number:0 } }, methods:{ handleClick:function(){ this.number++ // 这里涉及到子组件向父组件传值的内容,用emit触发一个change事件,在父组件进行监听 this.$emit(&apos;change&apos;) } } }) var vm = new Vue({ el:&apos;#root1&apos;, data:{ total:0 }, methods:{ handleChange:function(){ this.total=this.$refs.counter1.number + this.$refs.counter2.number } } })父子组件传值父组件怎么向子组件传递数据：通过属性 父组件向子组件通过属性绑定传递值，子组件用props属性接收 ； count前面不加冒号，传递的是字符串；加了冒号传递的是js表达式，这里就是数字。 &lt;div id=&quot;root&quot;&gt; &lt;counter :count=&apos;2&apos; &gt;&lt;/counter&gt; &lt;counter :count=&apos;3&apos; &gt;&lt;/counter&gt; &lt;/div&gt; var counter={ props:[&apos;count&apos;], template:&apos;&lt;div&gt;0&lt;/div&gt;&apos; } var vm = new Vue ({ el : &apos;#root&apos;, data:{} })​ 在vue中有一个单向数据流的概念，父组件可以随意向子组件传递参数，但是子组件不可以修改父组件传递过来的参数，原因是因为父组件传递过来的数据是对象的时候，可能有多个子组件调用，若是子组件可以直接修改的话，就会影响到其他子组件。 ​ 如果直接写this.count++的话，会出现一个警告，提示不要直接修改父组件传过来的数据，所以在此，定义data里面的number作为count的副本，然后修改number的值。 var counter={ //子组件 props:[&apos;count&apos;], data:function(){ return { number:this.count } }, template:&apos;&lt;div @click=&quot;handleClick&quot;&gt;&lt;/div&gt;&apos;, methods:{ handleClick:function(){ this.number = this.number + 2; } } } var vm = new Vue ({ //根组件 el : &apos;#root&apos;, data:{ total:5 }, components:{ counter:counter } })子组件怎么向父组件传递数据: 通过事件this.$emit(‘increase’,2);这里向外触发一个increase事件，同时可以传递参数每次改变都加步长2，step； 让父组件监听，在根组件中添加监听事件handleIncrease事件，传入步长2。 //父组件监听 var counter={ props:['count'], data:function(){ return { number:this.count } }, template:'', methods:{ handleClick:function(){ this.number = this.number + 2; this.$emit('increase',2); } } } var vm = new Vue ({ el : &apos;#root&apos;, data:{ total:5 }, components:{ counter:counter }, methods:{ handleIncrease:function(step){ //可以在触发的时候传递step参数 this.total += 2 } } })组件的参数校验与非props特性​ 如果要实现子组件要求父组件传递过来的参数一定要是字符串，在props里面不写数组，而是写对象，对象的键就是我们接收的参数的名字。 &lt;div id=&quot;root&quot;&gt; &lt;child content=&apos;hello world&apos;&gt;&lt;/child&gt; &lt;/div&gt;//子组件Vue.component(‘child’,{ props:{ // content:String // 这行的意思就是子组件接收的参数一定要是一个字符串类型; // content:[Number,String] // 可以用数组来定义传输参数的类型，可以是字符串/数组; content:{ type:String, required:false,//true说明了这个是必须传的,如果是false,那么不传也可以 default: ‘default value’,//假设不传的时候,会显示默认值‘default value’ validator:function(value){ //自定义校验器：先获取传入的参数值value,要求满足条件,要是没有满足，控制台就会报错 return (value.lenght&gt;5) } } }, template:’ header.intro-header{ position: relative; background-image: url('/img/home.jpg') } &lt;a class=&quot;tag&quot; href=&quot;/tags/#&lt; 黑马视频 &gt;知识点&quot; title=&quot;&lt; 黑马视频 &gt;知识点&quot;&gt;&lt; 黑马视频 &gt;知识点&lt;/a&gt; &lt;/div&gt; &lt;h1&gt;DOM相关知识点整理1&lt;/h1&gt; &lt;h2 class=&quot;subheading&quot;&gt;&lt;/h2&gt; &lt;span class=&quot;meta&quot;&gt;Posted by CodingWithAlice on June 23, 2019&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Post Container --&gt; &lt;div class=&quot; col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container&quot;&gt; &lt;h3 id=&quot;本文概要如下&quot;&gt;本文概要如下：&lt;/h3&gt; DOM树：把html页面或者是xml文件看成是一个文档，文档就是一个对象，这个文档中所有的标签都是元素，元素也可以看成是对象,标签(元素，对象)有很多，还有嵌套的关系,组成的这种层次结构，可以模拟成树形结构图，简称：树状图，就是DOM树。 DOM对象：通过DOM方式获取的元素得到的对象 获取元素多种方式： 根据 id属性 的值获取元素，返回来的是一个元素对象； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.getElementById(&quot;id属性的值&quot;);&lt;/code&gt;&lt;/p&gt; 根据 标签名字 获取元素，返回来的是一个伪数组，返回具有指定标签名的元素子元素集合；document.getElementsByTagName(\"标签名字\"); &lt;p&gt;&lt;strong&gt;下面的几个,有的浏览器不支持(ie8)&lt;/strong&gt;&lt;/p&gt; 根据 name属性 的值获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.getElementsByName(&quot;name属性的值&quot;)&lt;/code&gt;&lt;/p&gt; 根据 类样式 的名字来获取元素，返回来的是一个伪数组，里面保存了多个的DOM对象； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.getElementsByClassName(&quot;类样式的名字&quot;)&lt;/code&gt;&lt;/p&gt; 根据 选择器 获取元素，返回来的是一个元素对象，文档中匹配到指定的元素的第一个对象； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.querySelector(&quot;选择器的名字#btn&quot;); &lt;/code&gt;&lt;/p&gt; 根据 选择器 获取元素，返回来的是一个伪数组，文档中匹配到指定的元素的对象集合； &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;document.querySelectorAll(&quot;选择器的名字.cls&quot;) &lt;/code&gt;&lt;/p&gt; 获取boby、title、html标签 console.log(document.body); //获取的是元素--标签 console.log(document.title); //标签中的值 console.log(document.documentElement);//获取根元素html 操作基本标签的属性 src,title,alt,href,id属性 操作表单标签的属性吧+21 name,value,type,checked,selected,disabled,readonly 元素的样式操作 对象.style.属性=值; 对象.className=值; 为元素添加事件的操作：有事件源，触发和响应； 例如：按钮被点击,弹出对话框 其中：按钮—-&gt;事件源 点击—-&gt;事件名字 被点了—&gt;触发了 弹框了—&gt;响应 this的指向改变方法： 使用ES6的箭头函数，this在定义的时候被指定； 在函数内部使用_this=this;来保存this的指向； 使用apply()、call()、bind()； new实例化一个对象，this指向新对象； 接下来是详细分析介绍： DOM经常进行的操作： ​ • 获取元素 ​ • 动态创建元素 ​ • 对元素进行操作(设置其属性或调用其方法) ​ • 事件(什么时机做相应的操作) &lt;input type=\"button\" value=\"弹框\" onclick=\"alert('哈哈,我又变帅了')\" /&gt; 等价于 &lt;input type=\"button\" value=\"显示效果\" id=\"btn\"/&gt; //document.getElementById(\"id属性的值\");返回的是一个元素对象 document.getElementById(\"btn\").onclick=function () { alert(\"哈哈,我又变帅了\"); }; 等价于 var btnObj=document.getElementById(\"btn\"); btnObj.onclick=function(){ alert(\"这是分成两行代码的方式\"); } HTML：展示信息，展示数据的 XML：侧重于存储数据 根元素:html标签 元素(element)：页面中的所有的标签都是元素，元素可以看成是对象 文档 document：一个网页可以称为文档；页面中的顶级对象； 节点 Node：网页中的所有内容都是节点（标签、属性、文本[文字、换行、空格、回车]、注释等） 节点的属性：标签的属性；作用：为了将来获取很多节点，得到节点中的标签（元素），识别节点中的标签元素 点击事件：如下以案例举例出现的情况以及其功能 案例1：点击按钮显示图片：点击按钮的时候设置img标签的src属性有一个图片的路径 &lt;input type=\"button\" value=\"显示图片\" id=\"btn\"/&gt; &lt;img src=\"\" alt=\"\" id=\"im\" /&gt; var btnObj=document.getElementById(\"btn\"); //为按钮注册点击事件,添加事件处理函数 btnObj.onclick=function () { var imObj=document.getElementById(\"im\"); imObj.src=\"images/liuyan.jpg\"; imObj.width=\"300\"; imObj.height=\"400\"; }; 案例2：点击按钮，修改p标签的显示内容 &lt;input type=\"button\" value=\"设置p的内容\" id=\"btn\"/&gt; &lt;p id=\"p1\"&gt;我是一个p标签&lt;/p&gt; //根据id获取按钮,为按钮注册点击事件,添加事件处理函数 document.getElementById(\"btn\").onclick=function () { //根据id获取p标签,设置内容 document.getElementById(\"p1\").innerText=\"这是一个p\"; }; 注意技巧1： 凡是成对的标签,中间的文本内容,设置的时候,都使用 innerText 这个属性的方式； 案例3：点击按钮修改a标签的地址和热点文字 &lt;input type=\"button\" value=\"显示效果\" id=\"btn\"/&gt; &lt;a id=\"ak\" href=\"https://www.jiumodiary.com/\"&gt;鸠摩搜书&lt;/a&gt; //注册点击事件,添加事件处理函数 document.getElementById(\"btn\").onclick = function () { //设置href属性 document.getElementById(\"ak\").href = \"https://codingwithalice.github.io/\"; //设置文字内容 document.getElementById(\"ak\").innerText = \"CodingWithAlice\"; }; 可对javascript代码进行优化： //上面的代码，获取了两次id为ak的元素，增加了浏览器的负担。 //优化后的: document.getElementById(\"btn\").onclick = function () { //设置href属性，设置文字内容 var aObj = document.getElementById(\"ak\"); aObj.href = \"https://codingwithalice.github.io/\"; aObj.innerText = \"CodingWithAlice\"; }; 案例4：点击按钮设置多个p标签的文字内容 &lt;input type=\"button\" value=\"显示效果\" id=\"btn\"/&gt; &lt;div id=\"dv1\"&gt; &lt;p&gt;CtrlCoder&lt;/p&gt; &lt;p&gt;CtrlCoder&lt;/p&gt; &lt;/div&gt; &lt;div id=\"dv2\"&gt; &lt;p&gt;CodingWithAlice&lt;/p&gt; &lt;p&gt;CodingWithAlice&lt;/p&gt; &lt;p&gt;CodingWithAlice&lt;/p&gt; &lt;/div&gt; document.getElementById(\"btn\").onclick=function () { //根据标签名字获取标签,返回的是一个伪数组 var pObjs= document.getElementsByTagName(\"p\"); //循环遍历这个数组 for(var i=0;i&lt;pObjs.length;i++){ //每个p标签,设置文字 pObjs[i].innerText=\"我们都是p\"; } }; 案例5：点击按钮改变图片的alt和titile &lt;input type=\"button\" value=\"显示效果\" id=\"btn\"/&gt; &lt;img src=\"images/cangjingkong.jpg\" alt=\"CtrlCoder\" title=\"CodingWithAlice\"/&gt; document.getElementById(\"btn\").onclick = function () { //没有给img id名称，可以用tagname获取，但是一定要注意返回的是一个伪数组 var imgObjs = document.getElementsByTagName(\"img\"); imgObjs[0].alt = \"改了\";//调用的时候以数组的形式调用 imgObjs[0].title = \"实现吧\"; }; 案例6：点击按钮修改文本框的值 &lt;input type=\"button\" value=\"修改文本框的值\" id=\"btn\"/&gt;&lt;br/&gt; &lt;input type=\"text\" value=\"\"/&gt;&lt;br/&gt; &lt;input type=\"text\" value=\"\"/&gt;&lt;br/&gt; &lt;input type=\"text\" value=\"\"/&gt;&lt;br/&gt; &lt;input type=\"text\" value=\"\"/&gt;&lt;br/&gt; document.getElementById(\"btn\").onclick = function () { //获取所有的文本框，包含了第一个type为button var inputs = document.getElementsByTagName(\"input\"); for (var i = 0; i &lt; inputs.length; i++) { //用该元素的type属性判断这个元素是不是按钮 if (inputs[i].type != \"button\") { inputs[i].value = \"CodingWithAlice\"; } } }; 案例7：显示与隐藏 &lt;style&gt; div{ width: 300px; height: 200px; background-color: darkmagenta; } &lt;/style&gt; &lt;input type=\"button\" value=\"隐藏\" id=\"btn\"/&gt; &lt;input type=\"button\" value=\"显示\" id=\"btn2\"/&gt; &lt;div id=\"dv\"&gt;&lt;/div&gt; document.getElementById(\"btn\").onclick=function () { document.getElementById(\"dv\").style.display=\"none\"; }; document.getElementById(\"btn2\").onclick=function () { document.getElementById(\"dv\").style.display=\"block\"; }; 案例7：显示与隐藏优化：一个按钮的写法 &lt;style&gt; div{ width: 300px; height: 200px; background-color: darkmagenta; } .cls { display: none; } &lt;/style&gt; &lt;input type=\"button\" value=\"隐藏\" id=\"btn\"/&gt; &lt;div id=\"dv\"&gt;&lt;/div&gt; //点击按钮,通过类样式的方式设置div的显示和隐藏 document.getElementById(\"btn\").onclick = function () { //判断的是div是否应用了类样式 if (document.getElementById(\"dv\").className != \"cls\") { //没有应用类样式，现在是显示的,应该隐藏 document.getElementById(\"dv\").className = \"cls\"; //执行完上一句，就隐藏了，按钮改变 this.value = \"显示\"; } else { document.getElementById(\"dv\").className = \"\"; //执行完上一句，就显示了，按钮改变 this.value = \"隐藏\"; } }; 案例8：开关灯，body标签背景颜色 &lt;style&gt; .cls {background-color: black;} &lt;/style&gt; &lt;input type=\"button\" value=\"开/关灯\" id=\"btn\"/&gt; document.getElementById(\"btn\").onclick = function () { document.body.className = document.body.className != \"cls\" ? \"cls\" : \"\"; }; 案例9：单选和多选和下拉菜单 //单选 &lt;input type=\"button\" value=\"修改性别\" id=\"btn1\"/&gt; &lt;input type=\"radio\" value=\"1\" name=\"sex\"/&gt;男 &lt;input type=\"radio\" value=\"2\" name=\"sex\" id=\"rad1\"/&gt;女 &lt;input type=\"radio\" value=\"3\" name=\"sex\"/&gt;保密 document.getElementById(\"btn1\").onclick = function () { document.getElementById(\"rad1\").checked = true; }; 注意技巧2： 在表单标签中,如果属性和值只有一个，并且值是这个属性本身，那么在写js代码，DOM操作的时候，这个属性值，是布尔类型就可以了。 //多选 &lt;input type=\"button\" value=\"选择兴趣\" id=\"btn2\"/&gt; &lt;input type=\"checkbox\" value=\"1\" name=\"xingqu\" /&gt;吃饭 &lt;input type=\"checkbox\" value=\"2\" name=\"xingqu\" id=\"ck1\" /&gt;睡觉 &lt;input type=\"checkbox\" value=\"3\" name=\"xingqu\" id=\"ck2\" /&gt;打豆豆 document.getElementById(\"btn2\").onclick=function () { document.getElementById(\"ck1\").checked=true; document.getElementById(\"ck2\").checked=true; }; //下拉菜单 &lt;input type=\"button\" value=\"点菜\" id=\"btn\"/&gt; &lt;select name=\"\" id=\"ss\"&gt; &lt;option value=\"1\"&gt;油炸榴莲&lt;/option&gt; &lt;option value=\"2\"&gt;爆炒臭豆腐&lt;/option&gt; &lt;option value=\"3\"&gt;清蒸助教&lt;/option&gt; &lt;option value=\"4\" id=\"op1\"&gt;凉拌班主任&lt;/option&gt; &lt;option value=\"5\"&gt;红烧小苏&lt;/option&gt; &lt;/select&gt; document.getElementById(\"btn\").onclick=function () { //点击按钮选择菜 document.getElementById(\"op1\").selected=true; }; 案例10：改变文本域内的值 &lt;textarea name=\"\" id=\"tt\" cols=\"30\" rows=\"10\" readonly=\"readonly\"/disabled=“disabled”/readonly/disabled &gt; 注册用户的协议:某人问智者,大师:您觉得怎么做才是最快乐的?回答说:不要和愚者辩论这个人说:我不这么认为!大师说:您说的对. &lt;/textarea&gt; &lt;input type=\"button\" value=\"注册\" id=\"btn2\"/&gt; document.getElementById(\"btn2\").onclick=function () { //推荐使用value，textarea是表单标签。 document.getElementById(\"tt\").value=\"CodingWithAlice\"; //document.getElementById(\"tt\").innerText=\"哈哈\"; }; 案例11：点击小图(保留),显示大图 &lt;a href=\"images/1.jpg\" id=\"ak\"&gt; &lt;img src=\"images/1-small.jpg\" alt=\"\"&gt; &lt;/a&gt; &lt;img src=\"\" alt=\"\" id=\"big\"&gt; //保证小图的保留 //点击小图,下面显示大图 //点击超链接触发事件 document.getElementById(\"ak\").onclick=function () { document.getElementById(\"big\").src=this.href; return false;//保证小图的保留 }; 相册操作： &lt;ul id=\"imagegallery\"&gt; &lt;li&gt; &lt;a href=\"images/1.jpg\" title=\"A\"&gt; &lt;img src=\"images/1-small.jpg\" width=\"100\" alt=\"1\"/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/2.jpg\" title=\"B\"&gt; &lt;img src=\"images/2-small.jpg\" width=\"100\" alt=\"2\"/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/3.jpg\" title=\"C\"&gt; &lt;img src=\"images/3-small.jpg\" width=\"100\" alt=\"3\"/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/4.jpg\" title=\"D\"&gt; &lt;img src=\"images/4-small.jpg\" width=\"100\" alt=\"4\"/&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;img id=\"image\" src=\"images/placeholder.png\" alt=\"\" width=\"450\"/&gt;//点击链接a后显示大图的标签 &lt;p id=\"des\"&gt;选择一个图片&lt;/p&gt; //第一步：点击a标签,把a标签中的href的属性值给id为image的src属性 //第二步：把a的title属性的值给id为des的p标签赋值 var aObjs=document.getElementById(\"imagegallery\").getElementsByTagName(\"a\"); //循环遍历所有的a标签 for(var i=0;i&lt;aObjs.length;i++){ //为每个a标签注册点击事件 aObjs[i].onclick=function () { document.getElementById(\"image\").src=this.href; document.getElementById(\"des\").innerText=this.title; //阻止超链接默认的跳转 return false; }; } 案例12：隔行变色，奇红偶黄 &lt;input type=\"button\" value=\"隔行变色\" id=\"btn\"/&gt; &lt;ul id=\"uu\"&gt; &lt;li&gt;红旗&lt;/li&gt; &lt;li&gt;五菱宏光&lt;/li&gt; &lt;li&gt;奔驰&lt;/li&gt; &lt;li&gt;兰博基尼&lt;/li&gt; &lt;li&gt;哈弗&lt;/li&gt; &lt;/ul&gt; //第一种方法 document.getElementById(\"btn\").onclick=function () { //获取所有的li标签 var list=document.getElementById(\"uu\").getElementsByTagName(\"li\"); for(var i=0;i&lt;list.length;i++){ if(i%2==0){ list[i].style.backgroundColor=\"red\"; }else{ list[i].style.backgroundColor=\"yellow\"; } } }; //第二种方法：简写，善于利用三元表达式 document.getElementById(\"btn\").onclick = function () { //获取所有的li标签 var list = document.getElementById(\"uu\").getElementsByTagName(\"li\"); for (var i = 0; i &lt; list.length; i++) { list[i].style.backgroundColor = i % 2 == 0 ? \"red\" : \"yellow\"; } }; 案例13：排他功能 &lt;input type=\"button\" value=\"没怀孕\"/&gt; &lt;input type=\"button\" value=\"没怀孕\"/&gt; &lt;input type=\"button\" value=\"没怀孕\"/&gt; var btnObjs = document.getElementsByTagName(\"input\"); for (var i = 0; i &lt; btnObjs.length; i++) { //每个事件包括两件事情 btnObjs[i].onclick = function () { //第一：把所有的按钮的value值设置为默认的值:没怀孕 for (var j = 0; j &lt; btnObjs.length; j++) { btnObjs[j].value = \"没怀孕\"; } //第二：当前被点击的按钮设置为:怀孕了 this.value = \"怀孕了\"; }; } 注意技巧3： 设置被点击按钮的时候，不能用btnObjs[i].value ，因为事件是在触发的时候执行的，而 for 循环是在页面加载的时候执行完毕了，触发时间的时候，i=btnObjs.length 案例14：阻止超链接跳转 &lt;a href=\"images/lb1.jpg\" id='a1'&gt;&lt;img src=\"images/content_bg.jpg\" alt=\"\" id='im'&gt;&lt;/a&gt; //方法1： document.getElementById('im').onclick=function(){ this.src=document.getElementById('a1').href; return false;//阻止链接默认跳转 } &lt;!--方法2：return flase 写在行内式中--&gt; &lt;a href=\"http://www.baidu.com\" onclick=\"alert('哎呀,我被点了'); return false\"&gt;百度&lt;/a&gt; &lt;!--方法3：注意这里哦，这里调用f1的函数，返回的是一个false，所以这里要添加一个return--&gt; &lt;a href=\"http://www.baidu.com\" onclick=\"return f1()\"&gt;百度&lt;/a&gt; function f1() { alert(\"哇塞,好漂亮哦\"); return false; } 案例15：鼠标进入onmouseover、离开onmouseout改变标签的背景颜色 //获取所有的li标签 var list = document.getElementsByTagName(\"li\"); for (var i = 0; i &lt; list.length; i++) { //为li注册鼠标进入事件 list[i].onmouseover = function () { this.style.backgroundColor = \"yellow\"; }; //为li注册鼠标离开事件 list[i].onmouseout = function () { //恢复到这个标签默认的颜色 this.style.backgroundColor = \"\"; }; } 注意技巧4： getElementsByTagName获取的是数组，如果只使用一个，就要加序号getElementsByTagName(\"li\")[0] 设置元素的样式的方式： &lt;p&gt;​ 1. &lt;strong&gt;对象 ** . style . **属性 **= **值&lt;/strong&gt;；&lt;/p&gt; &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2. **对象** . className = **值**； 对象.className=“”使用的时候要注意，若只写想要设置的类名，会覆盖这个对象所有的类。 案例17：点击按钮，修改div的宽、高、背景颜色 &lt;input type=\"button\" value=\"设置样式\" id=\"btn\"/&gt; &lt;div id=\"dv\"&gt;&lt;/div&gt; //方法一：直接修改样式 .style.属性 = 值； document.getElementById$(\"btn\").onclick = function () { document.getElementById(\"dv\").style.width = \"300px\"; document.getElementById(\"dv\").style.height = \"200px\"; document.getElementById(\"dv\").style.backgroundColor = \"pink\"; //原来在css中是background-color }; /*方法二：通过给元素添加css样式属性 .className = 值； */ .cls {width: 300px;height: 200px;background-color: yellow;border: 2px solid red;} my$(\"btn\").onclick = function () { //在js代码中DOM操作的时候,设置元素的类样式,不用class关键字,应该使用,className my$(\"dv\").className=\"cls\"; //等价于：&lt;div id=\"dv\" class=“cls”/cls&gt;&lt;/div&gt; }; 注意技巧5： 如果在 css 中属性是多个单词（带-）的写法，那么在js代码中DOM操作的时候，要用驼峰命名法来调用 案例18：获取焦点onfocus，失去焦点事件onblur my$(\"txt\").onfocus = function () { //判断文本框的内容是不是默认的内容 if (this.value == \"请输入搜索内容\") { this.value = \"\";//清空文本框 this.style.color = \"black\"; } }; my$(\"txt\").onblur = function () { //1.判断字符串方式 if (this.value == \"\") { this.value = \"请输入搜索内容\"; this.style.color = \"gray\"; } //2.判断字符串长度方式，更推荐这种，数字判断的运行效率高 if (this.value.length == 0) { this.value = \"请输入搜索内容\"; this.style.color = \"gray\"; } }; 注意技巧6： 如果这个属性在浏览器中不支持，那么这个属性的类型是undefined。 案例19：自定义属性 设置自定义属性：setAttribute(\"属性的名字\",\"属性的值\"); 获取自定义属性的值：getAttribute(\"属性的名字\"); 移除义属性：removeAttribute(\"属性的名字\"); &lt;ul id=\"uu\"&gt; &lt;li&gt;数学成绩&lt;/li&gt; &lt;li&gt;英语成绩&lt;/li&gt; &lt;li&gt;语文成绩&lt;/li&gt; &lt;li&gt;科学成绩&lt;/li&gt; &lt;li&gt;历史成绩&lt;/li&gt; &lt;/ul&gt; var list=my$(\"uu\").getElementsByTagName(\"li\");//根据id获取ul标签,并且或者该标签中所有的li //为每个li添加自定义属性 for(var i=0;i&lt;list.length;i++){//循环遍历 list[i].setAttribute(\"score\",(i+1)*10);//添加在DOM对象上,不在标签中 list[i].onclick=function(){//点击每个li标签,获取对应的自定义属性值 alert(this.getAttribute(\"score\")); }; } //移除自定义属性 document.getElementById(\"btn\").onclick=function () { document.getElementById(\"dv\").removeAttribute(\"score\");//移除自定义属性，没值也没属性 document.getElementById(\"dv\").className=\"\";//移除元素的类样式，值没有了,但是属性还是有的 document.getElementById(\"dv\").removeAttribute(\"class\");//移除自定义属性，没值也没属性 }; 案例20：获取标签的内容 分类 名称 说明 使用时的区别 属性 innerHTML 设置或返回元素开始和结束标签之间的 HTML 保持编写的格式、样式标签&lt;&gt; 属性 innerText 设置或返回元素中去除所有标签的内容 去掉所有格式以及标签的纯文本内容 属性 textContent 设置或返回指定节点的文本内容 去掉标签后，保留文本样式，有回车 方法 document.write() 向文档写入指定的内容 方法 document.writeln() 向文档写入指定的内容并换行 &lt;hr style=&quot;visibility: hidden;&quot;&gt; &lt;ul class=&quot;pager&quot;&gt; &lt;li class=&quot;previous&quot;&gt; &lt;a href=&quot;/2019/06/21/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;内置对象和基本包装类型&quot;&gt; Previous&lt;br&gt; &lt;span&gt;内置对象和基本包装类型&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;next&quot;&gt; &lt;a href=&quot;/2019/06/25/Vue2.0%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;Vue2.0官方文档 知识点总结1&quot;&gt; Next&lt;br&gt; &lt;span&gt;Vue2.0官方文档 知识点总结1&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!--Gitalk评论start --&gt; &lt;!-- Gitalk end --&gt; &lt;/div&gt; &lt;!-- Side Catalog Container --&gt; &lt;div class=&quot; col-lg-2 col-lg-offset-0 visible-lg-block sidebar-container catalog-container&quot;&gt; &lt;div class=&quot;side-catalog&quot;&gt; &lt;hr class=&quot;hidden-sm hidden-xs&quot;&gt; &lt;h5&gt; &lt;a class=&quot;catalog-toggle&quot; href=&quot;#&quot;&gt;CATALOG&lt;/a&gt; &lt;/h5&gt; &lt;ul class=&quot;catalog-body&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Sidebar Container --&gt; &lt;div class=&quot; col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container&quot;&gt; &lt;!-- Featured Tags --&gt; &lt;section&gt; &lt;hr class=&quot;hidden-sm hidden-xs&quot;&gt; &lt;h5&gt;&lt;a href=&quot;/tags/&quot;&gt;FEATURED TAGS&lt;/a&gt;&lt;/h5&gt; &lt;div class=&quot;tags&quot;&gt; &lt;a href=&quot;/tags/#《JavaScript高级程序设计》&quot; title=&quot;《JavaScript高级程序设计》&quot; rel=&quot;6&quot;&gt; 《JavaScript高级程序设计》 &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 黑马视频 &gt;知识点&quot; title=&quot;&lt; 黑马视频 &gt;知识点&quot; rel=&quot;10&quot;&gt; &lt; 黑马视频 &gt;知识点 &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; Vue2.0官方文档 &gt; 知识点&quot; title=&quot;&lt; Vue2.0官方文档 &gt; 知识点&quot; rel=&quot;2&quot;&gt; &lt; Vue2.0官方文档 &gt; 知识点 &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 面试题整理 &gt;&quot; title=&quot;&lt; 面试题整理 &gt;&quot; rel=&quot;6&quot;&gt; &lt; 面试题整理 &gt; &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 算法题 &gt;&quot; title=&quot;&lt; 算法题 &gt;&quot; rel=&quot;2&quot;&gt; &lt; 算法题 &gt; &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 工作遇到的问题记录 &gt;&quot; title=&quot;&lt; 工作遇到的问题记录 &gt;&quot; rel=&quot;11&quot;&gt; &lt; 工作遇到的问题记录 &gt; &lt;/a&gt; &lt;a href=&quot;/tags/#&lt; 微信小程序的学习 &gt;&quot; title=&quot;&lt; 微信小程序的学习 &gt;&quot; rel=&quot;2&quot;&gt; &lt; 微信小程序的学习 &gt; &lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;!-- Friends Blog --&gt; &lt;hr&gt; &lt;h5&gt;FRIENDS&lt;/h5&gt; &lt;ul class=&quot;list-inline&quot;&gt; &lt;li&gt;&lt;a href=&quot;https://juejin.im/&quot;&gt;掘金&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/&quot;&gt;SegmentFault&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.v2ex.com/&quot;&gt;V2EX&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://readhub.cn/&quot;&gt;Readhub&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/&quot;&gt;OSCHINA&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://toutiao.io/posts/hot/7&quot;&gt;开发者头条&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; function async(u, c) { var d = document, t = 'script', o = d.createElement(t), s = d.getElementsByTagName(t)[0]; o.src = u; if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); } s.parentNode.insertBefore(o, s); } async(\"//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js\",function(){ anchors.options = { visible: 'always', placement: 'right', icon: '#' }; anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5'); }) /* place left on bigger screen */ @media all and (min-width: 800px) { .anchorjs-link{ position: absolute; left: -0.75em; font-size: 1.1em; margin-top : -0.1em; } } ' }) //根组件 var vm = new Vue({ el:'#root', })props特性指的就是父组件传递一个参数给子组件，同时子组件也定义了相应的props对父组件进行接收；props特性的特点：父组件定义了参数传递content=’hell’，但是在DOM结构里面是看不到的；子组件接收到父组件传递的值之后，就可以直接在子组件用插值表达式或者this.content获取到参数的值了非props特性指的是父组件传递一个参数给子组件，但是子组件没有定义props相关内容在这种情况下：页面会报错，content没有定义无法使用，获取不到参数内容这个属性会展示在子组件最外层的DOM标签的HTML的属性里面原生事件：&lt;child1 @click.native=’handle’&gt;​ 这里绑定的click是一个自定义事件，而不是点击事件，原生点击事件要和div标签绑在一起，先触发了原生click，触发了子组件中的handleChildClick事件，然后在这个事件中，向外触发了自定义事件click，而在父组件中监听了自定义click事件，触发了父组件中的handleClick。 &lt;div id=&quot;root&quot;&gt; &lt;child @click=&apos;handleClick&apos;&gt;&lt;/child&gt; &lt;!--这里不是原生事件，需要触发，是自定义事件--&gt; &lt;/div&gt; Vue.component(&apos;child&apos;,{ template:&apos;&lt;div @click=&quot;handleChildClick&quot;&gt;Child&lt;/div&gt;&apos;,//这里是原生事件 methods:{ handleChildClick:function(){ alert(&apos;handleChildClick&apos;) this.$emit(&apos;click&apos;) //触发自定义事件 } } }) var vm = new Vue({ el:&apos;#root&apos;, methods:{ handleClick:function(){ alert(&apos;click&apos;) } } })在自定义的click后面添加一个事件修饰符native，表示的就是这个click不再是自定义事件，而是一个原生的点击事件。 Vue.component('child1',{ template:'Child' }) var vm= new Vue({ el:'#root1', methods:{ handleClick:function(){ alert('success') } } }) 非父子组件间传值(BUS总线又称发布订阅模式又称观察者模式) Vue.prototype.bus = new Vue() 在Vue的prototype上面挂载了一个bus属性，这个属性指向一个vue的实例，只要后面创建vue，每一个都有bus属性，指向同一个实例。 &lt;!--想要两个child之间的值进行传递--&gt; &lt;div id=&quot;root&quot;&gt; &lt;child content=&apos;Alice&apos;&gt;&lt;/child&gt; &lt;child content=&apos;Sunny&apos;&gt;&lt;/child&gt; &lt;/div&gt; //在Vue的prototype上面挂载了一个bus属性，这个属性指向一个vue的实例 Vue.prototype.bus = new Vue() Vue.component(&apos;child&apos;, { data: function () { return { selfContent: this.content } }, props: { content: String //content的内容是从父组件传递过来的，不能直接改变（单向数据流） }, template: &apos;&lt;div @click=&quot;handleClick&quot;&gt;&lt;/div&gt;&apos;, methods: { handleClick: function () { this.bus.$emit(&apos;change&apos;, this.selfContent) //触发事件的时候进行内容传递 } }, // 这是一个生命周期钩子,每个组件被挂载的时候执行的函数,让组件进行监听bus的改变 mounted: function () { var this_ = this this.bus.$on(&apos;change&apos;, function (msg) { this_.selfContent = msg; }) } }) var vm = new Vue({ el: &apos;#root&apos; })插槽 slot如何让父组件用插槽优雅得向子组件传递DOM结构？先在父组件里面插入一个p标签；然后在模板中插入slot标签，slot标签会引用在父组件中插入的内容。slot特性： 在子组件template中直接使用 slot ，可以接收到子组件 child 里面传递DOM结构 Alice；默认内容，如果没有插槽内容，就会显示默认内容或者默认内容； Alice Vue.conponent(‘child’,{ template:&lt;div&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;slot&gt;默认内容&lt;/slot&gt; &lt;/div&gt;}) var vm = new Vue({ el”‘#root’})slot接收内容的时候，是无差别接收的，所以要使用 具名插槽 slot=’name’，也有默认值 通过这种写法，可以一次性传递多个DOM结构，而在子组件中使用具名插槽分别来使用不同部分的DOM结构 &lt;div id=&apos;root&apos;&gt; &lt;body-content&gt; &lt;div slot=&apos;header&apos;&gt;header&lt;/div&gt; &lt;div slot=&apos;footer&apos;&gt;footer&lt;/div&gt; &lt;/body-content&gt; &lt;/div&gt;Vue.conponent(‘body-content’,{ template:&lt;div&gt; &lt;slot name=&#39;header&#39;&gt;default header&lt;/slot&gt; &lt;div class=&#39;content&#39;&gt;content&lt;/div&gt; &lt;slot name=&#39;footer&#39;&gt;default footer&lt;/slot&gt; &lt;/div&gt;})var vm = new Vue({ el”‘#root’}) 作用域插槽 什么时候用这个作用域插槽的应用场景？ 回答：当子组件的DOM结构需要由外部传递进来的时候；子组件可以更方便地向父组件的插槽里面传数据。 首先，父组件调用子组件的时候，给子组件传了一个插槽，这个插槽叫做作用域插槽： 必须以标签包裹；同时这个插槽需要声明要从子组件接受的数据放在slot-scope=’props’；还要告诉子组件一个模板的信息(接收到的数据的展示方式)， 、标签等对这个数据进行展示。 - hello Vue.component(‘child’,{ //子组件 data:function(){ return { list:[1,2,3,4] //循环展示list内容 } }, template:` &lt;/slot&gt; &lt;/ul&gt; &lt;/div&gt;` }) var vm = new Vue({ el:&apos;#root&apos; })动态组件 实现toggle的办法： 常规方法 &lt;button @click=’handleBtnClick’&gt;change Vue.component(‘child-one’, { template: ‘child-one‘ }) Vue.component(‘child-two’, { template: ‘child-two‘ }) var vm = new Vue({ el: ‘#root’, data: { type: ‘child-one’ }, methods: { handleBtnClick: function () { this.type = this.type === ‘child-one’ ? ‘child-two’ : ‘child-one’ } } })接下来尝试用动态组件实现 动态组件：根据is里面数据的变化自动加载不同的组件 &lt;div id=&quot;root1&quot;&gt; &lt;component :is=&apos;type&apos;&gt;&lt;/component&gt; &lt;!-- component标签是vue自带的表示动态组件的标签 --&gt; &lt;button @click=&apos;handleBtnClick1&apos;&gt;change&lt;/button&gt; &lt;/div&gt; //和上面的vue代码是一样的 Vue.component(&apos;child-one&apos;, { template: &apos;&lt;div&gt;child-one&lt;/div&gt;&apos; }) Vue.component(&apos;child-two&apos;, { template: &apos;&lt;div&gt;child-two&lt;/div&gt;&apos; }) var vm = new Vue({ el: &apos;#root&apos;, data: { type: &apos;child-one&apos; }, methods: { handleBtnClick: function () { this.type = this.type === &apos;child-one&apos; ? &apos;child-two&apos; : &apos;child-one&apos; } } })​ 这里使用了一个v-once的指令，在组件第一次被渲染的时候，会直接放在内存里面，性能更高，有效提高一些静态内容的展示效率；如果不加v-once的时候，每次切换，都要在底层先销毁一个组件，再创建一个组件，耗费了一定的性能。 Vue.component(&apos;child-one&apos;, { template: &apos;&lt;div v-once&gt;child-one&lt;/div&gt;&apos; //和上面代码唯一不同的就是这里添加了v-once }) Vue.component(&apos;child-two&apos;, { template: &apos;&lt;div v-once&gt;child-two&lt;/div&gt;&apos; }) var vm = new Vue({ el: &apos;#root1&apos;, data: { type: &apos;child-two&apos; }, methods: { handleBtnClick1: function () { this.type = this.type === &apos;child-one&apos; ? &apos;child-two&apos; : &apos;child-one&apos; } } })","categories":[],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/tags/VUE/"}]},{"title":"微信小程序的学习","slug":"微信小程序的学习","date":"2019-09-13T07:53:09.000Z","updated":"2019-09-30T13:38:42.344Z","comments":true,"path":"2019/09/13/微信小程序的学习/","link":"","permalink":"http://yoursite.com/2019/09/13/微信小程序的学习/","excerpt":"#微信小程序的学习","text":"#微信小程序的学习 1.小程序的基本配置参考官方文档，（国人设计的，真心好用，通俗易懂） 2.小程序的双线程模型小程序的宿主环境是微信客户端， 宿主环境为了执行小程序的各种文件：wxml文件，wxss文件，js文件。 提供了小程序的双线程模型 双线程模型 WXML模块和WXSS样式运行于渲染层，渲染层使用WebView线程渲染(一个程序有多个页面，会使用多个webview的线程) JS脚本运行于逻辑层，逻辑层使用JsCore运行JS脚本 这两个线程都会由微信客户端进行中转交互 界面渲染的整体流程 在渲染层，宿主环境会把WXML转化成对应的JS对象 将JS对象再次转成真实的DOM树，交由渲染层线程渲染 数据变化是，逻辑层提供最新的变化数据，JS对象发生变化比较进行DIFF算法对比 将最新变化的内容反映到真实的DOM树中，更新UI 3.注册小程序流程注册APP时做些什么？ 判断小程序的进入场景 监听生命周期函数，在生命周期中执行对应的业务逻辑，比如在某个生命周期函数中获取微信用户的信息。 因为App()实例只有一个，并且是全局共享的（单例对象），所以我们可以将一些共享数据放在这里。 如何确定场景?在onLaunch和onShow生命周期回调函数中,会有options参数，其中有scene值 获取微信用户的基本信息的方式： wx.getUserInfo – 即将废弃的接口； button组件 – 将open-type改成getUserInfo，并且绑定bindgetuserinfo事件去获取； 使用open-data组件展示用户信息； 注册Page时做什么呢？ 在生命周期函数中发送网络请求，从服务器获取数据； 初始化一些数据，以方便被wxml引用展示； 监听wxml中的事件，绑定对应的事件函数； 其他一些监听（比如页面滚动、上拉刷新、下拉加载更多等） 4.WXSS&amp;&amp;WXML&amp;&amp;WXSWXSS的扩展尺寸单位 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px共有750个物理像素，则750rpx = 375px = 750物理像素1rpx = 0.5px = 1物理像素。 建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉的标准。 WXSS的扩展样式导入 在某些情况下，我们可能会将样式分在多个wxss文件中，方便对样式的管理。这个时候，我们就可以使用样式导入，来让单独的wxss生效我们可以在一个wxss中导入另一个wxss文件： 使用@import进行导入 @import后跟需要导入的外联样式表的相对路径（或者绝对路径也可以），用;表示语句结束。可以在app.wxss中导入这个样式，也可以在page.wxss导入这个样式#####官方样式库为了减少开发者样式开发的工作量，小程序官方提供了WeUI.wxss基本样式库 WXML的基本语法WXML基本格式： 类似于HTML代码：比如可以写成单标签，也可以写成双标签 必须有严格的闭合：没有闭合会导致编译错误 大小写敏感：class和Class是不同的属性开发中, 界面上展示的数据并不是写死的, 而是会根据服务器返回的数据, 或者用户的操作来进行改变.如果使用原生JS或者jQuery的话, 我们需要通过操作DOM来进行界面的更新.小程序和Vue/React一样, 提供了插值语法: Mustache语法(双大括号)Mustache语法不仅仅可以直接显示数据, 也可以使用表达式,并且可以绑定到属性.逻辑判断 wx:if – wx:elif – wx:else某些时候, 我们需要根据条件来决定一些内容是否渲染：当条件为true时, view组件会渲染出来当条件为false时, view组件不会渲染出来有多个条件:使用wx:if-wx:elif-wx:elsehidden属性:hidden是所有的组件都默认拥有的属性,当hidden属性为true时, 组件会被隐藏当hidden属性为false时, 组件会显示出来hidden和wx:if的区别hidden控制隐藏和显示是控制是否添加hidden属性wx:if是控制组件是否渲染的 列表渲染 – wx:for基础我们知道，在实际开发中，服务器经常返回各种列表数据，我们不可能一一从列表中取出数据进行展示；需要通过for循环的方式，遍历所有的数据，一次性进行展示；在组件中，我们可以使用wx:for来遍历一个数组 （字符串 - 数字）默认情况下，遍历后在wxml中可以使用一个变量index，保存的是当前遍历数据的下标值。数组中对应某项的数据，使用变量名item获取。 block标签什么是block标签？某些情况下，我们需要使用 wx:if 或 wx:for时，可能需要包裹一组组件标签我们希望对这一组组件标签进行整体的操作，使用一个view标签或者block标签包裹 block标签的意义并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。12345678使用block有两个好处：1）将需要进行遍历或者判断的内容进行包裹。2）将遍历和判断的属性放在block便签中，不影响普通属性的阅读，提高代码的可读性。#### 列表渲染 – item/index名称默认情况下，item – index的名字是固定的但是某些情况下，我们可能想使用其他名称,或者当出现多层遍历时，名字会重复这个时候，我们可以指定item和index的名称,```wx:for-item=&quot;指定名称&quot;，wx:for-index=&quot;指定名称&quot; 列表渲染 – key作用这个其实和小程序内部也使用了虚拟DOM有关系（和Vue、React很相似）。当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点,我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的。即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？所以我们需要使用key来给每个节点做一个唯一标识Diff算法就可以正确的识别此节点,找到正确的位置区插入新的节点。所以一句话，key的作用主要是为了高效的更新虚拟DOM。 模板用法WXML提供模板（template），可以在模板中定义代码片段，在不同的地方调用。(是一种wxml代码的复用机制)  使用 name 属性，作为模板的名字, 然后在 &lt;template/&gt; 内定义代码片段 wxml的引入小程序wxml中提供了两种引入文件的方式：import和includeImport引入：import 可以在该文件中使用目标文件定义的 template注意：wxml中不能递归引入（也就是A引入了B的template，不会引入B中引入C的template）include引入:include 可以将目标文件中除了 &lt;template/&gt; &lt;wxs/&gt;外的整个代码引入，相当于是拷贝到 include 位置. wxs模块WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。 为什么要设计WXS语言呢？在WXML中是不能直接调用Page/Component中定义的函数的.但是某些情况, 我们可以希望使用函数来处理WXML中的数据(类似于Vue中的过滤器)，这个时候就使用WXS了.WXS使用的限制和特点： WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API。 WXS 函数不能作为组件的事件回调。 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。 WXS有两种写法： 写在&lt;wxs&gt;标签中 写在以.wxs结尾的文件中 5.组件化开发类似于页面，自定义组件由 json wxml wxss js 4个文件组成。 自定义组件的步骤：1.首先需要在 json 文件中进行自定义组件声明（将component 字段设为 true 可这一组文件设为自定义组件）：2.在wxml中编写属于我们组件自己的模板3.在wxss中编写属于我们组件自己的相关样式4.在js文件中, 可以定义数据或组件内部的相关逻辑(后续我们再使用) 使用自定义组件和细节注意事项一些需要注意的细节：因为 WXML 节点标签名只能是 小写字母、中划线和下划线 的组合，所以自定义组件的标签名也只能包含这些字符。自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用usingComponents 字段）。自定义组件和页面所在项目根目录名 不能以“wx-”为前缀，否则会报错。如果在app.json的usingComponents声明某个组件，那么所有页面和组件可以直接使用该组件。 组件的样式细节课题一：组件内的样式 对 外部样式 的影响结论一：组件内的class样式，只对组件wxml内的节点生效, 对于引用组件的Page页面不生效。结论二：组件内不能使用id选择器、属性选择器、标签选择器 课题二：外部样式 对 组件内样式 的影响结论一：外部使用class的样式，只对外部wxml的class生效，对组件内是不生效的结论二：外部使用了id选择器、属性选择器不会对组件内产生影响结论三：外部使用了标签选择器，会对组件内产生影响 整体结论:组件内的class样式和组件外的class样式, 默认是有一个隔离效果的；为了防止样式的错乱，官方不推荐使用id、属性、标签选择器； 课题三：如何让class可以相互影响在Component对象中，可以传入一个options属性，其中options属性中有一个styleIsolation（隔离）属性。styleIsolation有三个取值： isolated 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（默认取值）； apply-shared 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面； shared 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 其他一些相关样式细节，参考官网 组件和页面通信很多情况下，组件内展示的内容（数据、样式、标签），并不是在组件内写死的，而且可以由使用者来决定。 向组件传递数据 - properties给组件传递数据：大部分情况下，组件只负责布局和样式，内容是由使用组件的对象决定的。所以，我们经常需要从外部传递数据给我们的组件，让我们的组件来进行展示。如何传递呢？使用properties属性：支持的类型：String、Number、BooleanObject、Array、null（不限制类型） 向组件传递样式 - externalClasses给组件传递样式：有时候，我们不希望将样式在组件内固定不变，而是外部可以决定样式。这个时候，我们可以使用externalClasses属性：1.在Component对象中，定义externalClasses属性2.在组件内的wxml中使用externalClasses属性中的class3.在页面中传入对应的class，并且给这个class设置样式 组件向外传递事件 – 自定义事件有时候是自定义组件内部发生了事件，需要告知使用者，这个时候可以使用自定义事件页面直接调用组件方法:this.selectComponent 什么是插槽slot翻译为插槽：插槽的目的是让我们原来的设备具备更多的扩展性。 组件的插槽：组件的插槽也是为了让我们封装的组件更加具有扩展性。让使用者可以决定组件内部的一些内容到底展示什么。 单个插槽的使用除了内容和样式可能由外界决定之外，也可能外界想决定显示的方式比如我们有一个组件定义了头部和尾部，但是中间的内容可能是一段文字，也可能是一张图片，或者是一个进度条。在不确定外界想插入什么其他组件的前提下，我们可以在组件内预留插槽 多个插槽的使用有时候为了让组件更加灵活, 我们需要定义多个插槽： Component构造器Component构造器用户创建我们的自定义组件对象, 调用Component时, 可以传入属性、数据、方法等 小程序得系统API网络请求 – 基本使用微信提供了专属的API接口,用于网络请求: wx.request(Object object)比较关键的几个属性解析:url: 必传, 不然请求什么.data: 请求参数method: 请求的方式success: 成功时的回调fail: 失败时的回调 网络请求 – 请求封装目前我们采用的网络请求是非常古老的请求方式, 我们将它封装成Promise的方式。 展示弹窗小程序中展示弹窗有四种方式: showToast、showModal、showLoading、showActionSheet 页面分享分享是小程序扩散的一种重要方式，小程序中有两种分享方式：点击右上角的菜单按钮，之后点击转发，或者点击某一个按钮，直接转发当我们转发给好友一个小程序时，通常小程序中会显示一些信息：如何决定这些信息的展示呢？通过 onShareAppMessage 小程序的登录流程小程序登录流程图：1.调用wx.login获取code2.调用wx.request发送code到我们自己的服务器（我们自己的服务器会返回一个登录态的标识，比如token）3.将登录态的标识token进行存储，以便下次使用4.请求需要登录态标识的接口时，携带token 界面跳转界面的跳转有两种方式：通过navigator组件 和 通过wx的API跳转navigator组件主要就是用于界面的跳转的 open-type的取值：redirect：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面，并且不能返回。（不是一个压栈）switchTab：跳转到 tabBar 页面，并关闭其他所有非tabBar 页面。（需要在tabBar中定义的）eLaunch：关闭所有的页面，打开应用中某个页面。（直接展示某个页面，并且可以跳转到tabBar页面） 导航返回有两个属性来起作用：open-type：navigateBack（表示该navigator组件用于返回）delta：返回的层级（指定返回的层级，open-type必须是navigateBack才生效） 如何在界面跳转过程中我们需要相互传递一些数据，应该如何完成呢？ 数据传递 – 传递过程首页 -&gt; 详情页：通过修改URL传递参数详情页 -&gt; 首页：返回时携带数据有两个问题需要考虑 问题一: 在什么地方修改数据 如果你是监听按钮或者navigator的点击来返回时, 可以通过bindtap来映射到某个函数, 在函数中完成. 但是这种方式不能监听左上角返回按钮的点击. 所以我们选择在onUnload中修改数据问题二: 如何修改数据 小程序并没有提供直接修改数据的方法. 但是可以通过getCurrentPages来获取所有的页面, 然后使用页面对象的setData({})函数来修改 代码的跳转和返回很多情况下，我们并不喜欢使用navigator组件来进行跳转：可能我们希望用户点击了某个button或者view时，对该button或者view进行监听之后，通过相关的代码逻辑实现跳转对此，微信也提供了对应的API接口：wx.navigateTo(url[, ])wx.navigateBack([delta]) 至此微信小程序基础知识过了一遍，更多知识参考官方文档。（下面开始项目实战）","categories":[],"tags":[{"name":"小程序 微信","slug":"小程序-微信","permalink":"http://yoursite.com/tags/小程序-微信/"}]},{"title":"【转载】hexo 文章保存为草稿","slug":"hexo文章保存为草稿","date":"2019-09-12T07:40:45.000Z","updated":"2019-09-28T16:32:11.852Z","comments":true,"path":"2019/09/12/hexo文章保存为草稿/","link":"","permalink":"http://yoursite.com/2019/09/12/hexo文章保存为草稿/","excerpt":"转载自： https://novnan.github.io/Hexo/hexo-draft/","text":"转载自： https://novnan.github.io/Hexo/hexo-draft/ 传统建立文章方式一般我们都会使用 new ``` 来建立文章，这种建立方法会将新文章建立在 source/_posts 目录下，当使用 hexo generate 编译 markdown 文件时，会将其 HTML 结果编译在 public 目录下，之后 hexo deploy 将会把 public 目录下所有文章部署到 GitHub，这是我们熟悉的 Hexo 流程。12345这种建立文章方式的缺点是：若我们同时编辑多篇文章，只要其中一篇文章尚未编辑完成，也会随着 hexo deploy 一起部署到 GitHub，也就是 GitHub 可能会看到我们尚未完成的文章。## 建立文章草稿```$ hexo new draft &lt;title&gt; Hexo 另外提供 draft 机制，它的原理是新文章将建立在 source/_drafts 目录下，因此 hexo generate 并不会将其编译到 public 目录下，所以 hexo deploy 也不会将其部署到 GitHub。 本机预览草稿hexo S --draft```1234虽然 hexo generate 不会编译 source/_drafts 目录下的文章，但 Hexo 的 Hexo server 另外提供 --draft 参数，这让我们只要搭配 hexo-browsersync plugins，就可以达到一边编辑 markdown 文章，一边使用浏览器预览的目的。## 将草稿发布为正式文章```$ hexo P &lt;filename&gt; 其中 &lt;filename&gt; 为不包含 md 后缀的文章名称。它的原理只是将文章从 source/_drafts 移动到 source/_posts 而已。 之后的 hexo generate 与 hexo deploy 的用法就完全一样了。 若日后想将正式文章转为为草稿，只需手动将文章从 source/_posts 目录移动到 source/_drafts 目录即可。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"[终于创建好了我的博客]","slug":"终于创建好了我的博客","date":"2019-09-10T17:27:25.000Z","updated":"2019-09-26T13:47:37.067Z","comments":true,"path":"2019/09/11/终于创建好了我的博客/","link":"","permalink":"http://yoursite.com/2019/09/11/终于创建好了我的博客/","excerpt":"","text":"哈哈哈哈，兜兜转转，折腾了好久，换了好多种主题和Blog的框架终于搞定了自己的Blog，记录下自己。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]