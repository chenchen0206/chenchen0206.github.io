[{"title":"微信小程序的学习","slug":"微信小程序的学习","date":"2019-09-13T07:53:09.000Z","updated":"2019-09-29T00:41:01.017Z","comments":true,"path":"2019/09/13/微信小程序的学习/","link":"","permalink":"http://yoursite.com/2019/09/13/微信小程序的学习/","excerpt":"#微信小程序的学习","text":"#微信小程序的学习 1.小程序的基本配置参考官方文档，（国人设计的，真心好用，通俗易懂） 2.小程序的双线程模型小程序的宿主环境是微信客户端， 宿主环境为了执行小程序的各种文件：wxml文件，wxss文件，js文件。 提供了小程序的双线程模型 双线程模型 WXML模块和WXSS样式运行于渲染层，渲染层使用WebView线程渲染(一个程序有多个页面，会使用多个webview的线程) JS脚本运行于逻辑层，逻辑层使用JsCore运行JS脚本 这两个线程都会由微信客户端进行中转交互 界面渲染的整体流程 在渲染层，宿主环境会把WXML转化成对应的JS对象 将JS对象再次转成真实的DOM树，交由渲染层线程渲染 数据变化是，逻辑层提供最新的变化数据，JS对象发生变化比较进行DIFF算法对比 将最新变化的内容反映到真实的DOM树中，更新UI 3.注册小程序流程注册APP时做些什么？ 判断小程序的进入场景 监听生命周期函数，在生命周期中执行对应的业务逻辑，比如在某个生命周期函数中获取微信用户的信息。 因为App()实例只有一个，并且是全局共享的（单例对象），所以我们可以将一些共享数据放在这里。 如何确定场景?在onLaunch和onShow生命周期回调函数中,会有options参数，其中有scene值 获取微信用户的基本信息的方式： wx.getUserInfo – 即将废弃的接口； button组件 – 将open-type改成getUserInfo，并且绑定bindgetuserinfo事件去获取； 使用open-data组件展示用户信息； 注册Page时做什么呢？ 在生命周期函数中发送网络请求，从服务器获取数据； 初始化一些数据，以方便被wxml引用展示； 监听wxml中的事件，绑定对应的事件函数； 其他一些监听（比如页面滚动、上拉刷新、下拉加载更多等） 4.WXSS&amp;&amp;WXML&amp;&amp;WXSWXSS的扩展尺寸单位 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px共有750个物理像素，则750rpx = 375px = 750物理像素1rpx = 0.5px = 1物理像素。 建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉的标准。 WXSS的扩展样式导入 在某些情况下，我们可能会将样式分在多个wxss文件中，方便对样式的管理。这个时候，我们就可以使用样式导入，来让单独的wxss生效我们可以在一个wxss中导入另一个wxss文件： 使用@import进行导入 @import后跟需要导入的外联样式表的相对路径（或者绝对路径也可以），用;表示语句结束。可以在app.wxss中导入这个样式，也可以在page.wxss导入这个样式#####官方样式库为了减少开发者样式开发的工作量，小程序官方提供了WeUI.wxss基本样式库 WXML的基本语法WXML基本格式： 类似于HTML代码：比如可以写成单标签，也可以写成双标签 必须有严格的闭合：没有闭合会导致编译错误 大小写敏感：class和Class是不同的属性开发中, 界面上展示的数据并不是写死的, 而是会根据服务器返回的数据, 或者用户的操作来进行改变.如果使用原生JS或者jQuery的话, 我们需要通过操作DOM来进行界面的更新.小程序和Vue/React一样, 提供了插值语法: Mustache语法(双大括号)Mustache语法不仅仅可以直接显示数据, 也可以使用表达式,并且可以绑定到属性.逻辑判断 wx:if – wx:elif – wx:else某些时候, 我们需要根据条件来决定一些内容是否渲染：当条件为true时, view组件会渲染出来当条件为false时, view组件不会渲染出来有多个条件:使用wx:if-wx:elif-wx:elsehidden属性:hidden是所有的组件都默认拥有的属性,当hidden属性为true时, 组件会被隐藏当hidden属性为false时, 组件会显示出来hidden和wx:if的区别hidden控制隐藏和显示是控制是否添加hidden属性wx:if是控制组件是否渲染的 列表渲染 – wx:for基础我们知道，在实际开发中，服务器经常返回各种列表数据，我们不可能一一从列表中取出数据进行展示；需要通过for循环的方式，遍历所有的数据，一次性进行展示；在组件中，我们可以使用wx:for来遍历一个数组 （字符串 - 数字）默认情况下，遍历后在wxml中可以使用一个变量index，保存的是当前遍历数据的下标值。数组中对应某项的数据，使用变量名item获取。 block标签什么是block标签？某些情况下，我们需要使用 wx:if 或 wx:for时，可能需要包裹一组组件标签我们希望对这一组组件标签进行整体的操作，使用一个view标签或者block标签包裹 block标签的意义&lt;block/&gt; 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。使用block有两个好处：1）将需要进行遍历或者判断的内容进行包裹。2）将遍历和判断的属性放在block便签中，不影响普通属性的阅读，提高代码的可读性。 列表渲染 – item/index名称默认情况下，item – index的名字是固定的但是某些情况下，我们可能想使用其他名称,或者当出现多层遍历时，名字会重复这个时候，我们可以指定item和index的名称```wx:for-item=”指定名称”，wx:for-index=”指定名称” 列表渲染 – key作用◼ 我们看到，使用wx:for时，会报一个警告： 这个提示告诉我们，可以添加一个key来提供性能。 ◼ 为什么需要这个key属性呢（了解）？ 这个其实和小程序内部也使用了虚拟DOM有关系（和Vue、React很相似）。◼ 当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点 我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的。 即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？◼ 所以我们需要使用key来给每个节点做一个唯一标识 Diff算法就可以正确的识别此节点 找到正确的位置区插入新的节点。◼ 所以一句话，key的作用主要是为了高效的更新虚拟DOM。Made by coderwhywww.itlike.com模板用法◼ WXML提供模板（template），可以在模板中定义代码片段，在不同的地方调用。(是一种wxml代码的复用机制)  使用 name 属性，作为模板的名字, 然后在 内定义代码片段Made by coderwhywww.itlike.comwxml的引入◼ 小程序wxml中提供了两种引入文件的方式：import和include◼ Import引入：import 可以在该文件中使用目标文件定义的 template◼ 比如下面的演练： 在item.wxml中定义一个item的template 在home.wxml中引入，并且使用template◼ 注意：wxml中不能递归引入（也就是A引入了B的template，不会引入B中引入C的template）Made by coderwhywww.itlike.cominclude引入◼ include 可以将目标文件中除了 外的整个代码引入，相当于是拷贝到 include 位置：Made by coderwhywww.itlike.comwxs模块◼ WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。 官方：WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。（不过基本一致）◼ 为什么要设计WXS语言呢？ 在WXML中是不能直接调用Page/Component中定义的函数的.  但是某些情况, 我们可以希望使用函数来处理WXML中的数据(类似于Vue中的过滤器)，这个时候就使用WXS了 ◼ WXS使用的限制和特点： WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API。  WXS 函数不能作为组件的事件回调。 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。Made by coderwhywww.itlike.comWXS的写法◼ WXS有两种写法： - 写在标签中 - 写在以.wxs结尾的文件中","categories":[],"tags":[{"name":"小程序 微信","slug":"小程序-微信","permalink":"http://yoursite.com/tags/小程序-微信/"}]},{"title":"【转载】hexo 文章保存为草稿","slug":"hexo文章保存为草稿","date":"2019-09-12T07:40:45.000Z","updated":"2019-09-28T16:32:11.852Z","comments":true,"path":"2019/09/12/hexo文章保存为草稿/","link":"","permalink":"http://yoursite.com/2019/09/12/hexo文章保存为草稿/","excerpt":"转载自： https://novnan.github.io/Hexo/hexo-draft/","text":"转载自： https://novnan.github.io/Hexo/hexo-draft/ 传统建立文章方式一般我们都会使用 new ``` 来建立文章，这种建立方法会将新文章建立在 source/_posts 目录下，当使用 hexo generate 编译 markdown 文件时，会将其 HTML 结果编译在 public 目录下，之后 hexo deploy 将会把 public 目录下所有文章部署到 GitHub，这是我们熟悉的 Hexo 流程。12345这种建立文章方式的缺点是：若我们同时编辑多篇文章，只要其中一篇文章尚未编辑完成，也会随着 hexo deploy 一起部署到 GitHub，也就是 GitHub 可能会看到我们尚未完成的文章。## 建立文章草稿```$ hexo new draft &lt;title&gt; Hexo 另外提供 draft 机制，它的原理是新文章将建立在 source/_drafts 目录下，因此 hexo generate 并不会将其编译到 public 目录下，所以 hexo deploy 也不会将其部署到 GitHub。 本机预览草稿hexo S --draft```1234虽然 hexo generate 不会编译 source/_drafts 目录下的文章，但 Hexo 的 Hexo server 另外提供 --draft 参数，这让我们只要搭配 hexo-browsersync plugins，就可以达到一边编辑 markdown 文章，一边使用浏览器预览的目的。## 将草稿发布为正式文章```$ hexo P &lt;filename&gt; 其中 &lt;filename&gt; 为不包含 md 后缀的文章名称。它的原理只是将文章从 source/_drafts 移动到 source/_posts 而已。 之后的 hexo generate 与 hexo deploy 的用法就完全一样了。 若日后想将正式文章转为为草稿，只需手动将文章从 source/_posts 目录移动到 source/_drafts 目录即可。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"[终于创建好了我的博客]","slug":"终于创建好了我的博客","date":"2019-09-10T17:27:25.000Z","updated":"2019-09-26T13:47:37.067Z","comments":true,"path":"2019/09/11/终于创建好了我的博客/","link":"","permalink":"http://yoursite.com/2019/09/11/终于创建好了我的博客/","excerpt":"","text":"哈哈哈哈，兜兜转转，折腾了好久，换了好多种主题和Blog的框架终于搞定了自己的Blog，记录下自己。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]