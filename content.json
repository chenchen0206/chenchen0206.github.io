[{"title":"微信小程序的学习","slug":"微信小程序的学习","date":"2019-09-13T07:53:09.000Z","updated":"2019-09-28T16:30:27.394Z","comments":true,"path":"2019/09/13/微信小程序的学习/","link":"","permalink":"http://yoursite.com/2019/09/13/微信小程序的学习/","excerpt":"#微信小程序的学习","text":"#微信小程序的学习 1.小程序的基本配置参考官方文档，（国人设计的，真心好用，通俗易懂） 2.小程序的双线程模型小程序的宿主环境是微信客户端，1.宿主环境为了执行小程序的各种文件：wxml文件，wxss文件，js文件。2.提供了小程序的双线程模型 双线程模型1.WXML模块和WXSS样式运行于渲染层，渲染层使用WebView线程渲染(一个程序有多个页面，会使用多个webview的线程)2.JS脚本运行于逻辑层，逻辑层使用JsCore运行JS脚本3.这两个线程都会由微信客户端进行中转交互 界面渲染的整体流程1.在渲染层，宿主环境会把WXML转化成对应的JS对象2.将JS对象再次转成真实的DOM树，交由渲染层线程渲染3.数据变化是，逻辑层提供最新的变化数据，JS对象发生变化比较进行DIFF算法对比4.将最新变化的内容反映到真实的DOM树中，更新UI 3.注册小程序流程注册APP时做些什么？1.判断小程序的进入场景2.监听生命周期函数，在生命周期中执行对应的业务逻辑，比如在某个生命周期函数中获取微信用户的信息。3.因为App()实例只有一个，并且是全局共享的（单例对象），所以我们可以将一些共享数据放在这里。 如何确定场景?在onLaunch和onShow生命周期回调函数中,会有options参数，其中有scene值 获取微信用户的基本信息的方式：1.wx.getUserInfo – 即将废弃的接口；2.button组件 – 将open-type改成getUserInfo，并且绑定bindgetuserinfo事件去获取；3.使用open-data组件展示用户信息； 注册Page时做什么呢？1.在生命周期函数中发送网络请求，从服务器获取数据；2.初始化一些数据，以方便被wxml引用展示；3.监听wxml中的事件，绑定对应的事件函数；4.其他一些监听（比如页面滚动、上拉刷新、下拉加载更多等）","categories":[],"tags":[{"name":"小程序 微信","slug":"小程序-微信","permalink":"http://yoursite.com/tags/小程序-微信/"}]},{"title":"【转载】hexo 文章保存为草稿","slug":"hexo文章保存为草稿","date":"2019-09-12T07:40:45.000Z","updated":"2019-09-28T16:32:11.852Z","comments":true,"path":"2019/09/12/hexo文章保存为草稿/","link":"","permalink":"http://yoursite.com/2019/09/12/hexo文章保存为草稿/","excerpt":"转载自： https://novnan.github.io/Hexo/hexo-draft/","text":"转载自： https://novnan.github.io/Hexo/hexo-draft/ 传统建立文章方式一般我们都会使用 new ``` 来建立文章，这种建立方法会将新文章建立在 source/_posts 目录下，当使用 hexo generate 编译 markdown 文件时，会将其 HTML 结果编译在 public 目录下，之后 hexo deploy 将会把 public 目录下所有文章部署到 GitHub，这是我们熟悉的 Hexo 流程。12345这种建立文章方式的缺点是：若我们同时编辑多篇文章，只要其中一篇文章尚未编辑完成，也会随着 hexo deploy 一起部署到 GitHub，也就是 GitHub 可能会看到我们尚未完成的文章。## 建立文章草稿```$ hexo new draft &lt;title&gt; Hexo 另外提供 draft 机制，它的原理是新文章将建立在 source/_drafts 目录下，因此 hexo generate 并不会将其编译到 public 目录下，所以 hexo deploy 也不会将其部署到 GitHub。 本机预览草稿hexo S --draft```1234虽然 hexo generate 不会编译 source/_drafts 目录下的文章，但 Hexo 的 Hexo server 另外提供 --draft 参数，这让我们只要搭配 hexo-browsersync plugins，就可以达到一边编辑 markdown 文章，一边使用浏览器预览的目的。## 将草稿发布为正式文章```$ hexo P &lt;filename&gt; 其中 &lt;filename&gt; 为不包含 md 后缀的文章名称。它的原理只是将文章从 source/_drafts 移动到 source/_posts 而已。 之后的 hexo generate 与 hexo deploy 的用法就完全一样了。 若日后想将正式文章转为为草稿，只需手动将文章从 source/_posts 目录移动到 source/_drafts 目录即可。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"[终于创建好了我的博客]","slug":"终于创建好了我的博客","date":"2019-09-10T17:27:25.000Z","updated":"2019-09-26T13:47:37.067Z","comments":true,"path":"2019/09/11/终于创建好了我的博客/","link":"","permalink":"http://yoursite.com/2019/09/11/终于创建好了我的博客/","excerpt":"","text":"哈哈哈哈，兜兜转转，折腾了好久，换了好多种主题和Blog的框架终于搞定了自己的Blog，记录下自己。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]