[{"title":"微信小程序的学习","slug":"微信小程序的学习","date":"2019-09-13T07:53:09.000Z","updated":"2019-09-30T13:38:42.344Z","comments":true,"path":"2019/09/13/微信小程序的学习/","link":"","permalink":"http://yoursite.com/2019/09/13/微信小程序的学习/","excerpt":"#微信小程序的学习","text":"#微信小程序的学习 1.小程序的基本配置参考官方文档，（国人设计的，真心好用，通俗易懂） 2.小程序的双线程模型小程序的宿主环境是微信客户端， 宿主环境为了执行小程序的各种文件：wxml文件，wxss文件，js文件。 提供了小程序的双线程模型 双线程模型 WXML模块和WXSS样式运行于渲染层，渲染层使用WebView线程渲染(一个程序有多个页面，会使用多个webview的线程) JS脚本运行于逻辑层，逻辑层使用JsCore运行JS脚本 这两个线程都会由微信客户端进行中转交互 界面渲染的整体流程 在渲染层，宿主环境会把WXML转化成对应的JS对象 将JS对象再次转成真实的DOM树，交由渲染层线程渲染 数据变化是，逻辑层提供最新的变化数据，JS对象发生变化比较进行DIFF算法对比 将最新变化的内容反映到真实的DOM树中，更新UI 3.注册小程序流程注册APP时做些什么？ 判断小程序的进入场景 监听生命周期函数，在生命周期中执行对应的业务逻辑，比如在某个生命周期函数中获取微信用户的信息。 因为App()实例只有一个，并且是全局共享的（单例对象），所以我们可以将一些共享数据放在这里。 如何确定场景?在onLaunch和onShow生命周期回调函数中,会有options参数，其中有scene值 获取微信用户的基本信息的方式： wx.getUserInfo – 即将废弃的接口； button组件 – 将open-type改成getUserInfo，并且绑定bindgetuserinfo事件去获取； 使用open-data组件展示用户信息； 注册Page时做什么呢？ 在生命周期函数中发送网络请求，从服务器获取数据； 初始化一些数据，以方便被wxml引用展示； 监听wxml中的事件，绑定对应的事件函数； 其他一些监听（比如页面滚动、上拉刷新、下拉加载更多等） 4.WXSS&amp;&amp;WXML&amp;&amp;WXSWXSS的扩展尺寸单位 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px共有750个物理像素，则750rpx = 375px = 750物理像素1rpx = 0.5px = 1物理像素。 建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉的标准。 WXSS的扩展样式导入 在某些情况下，我们可能会将样式分在多个wxss文件中，方便对样式的管理。这个时候，我们就可以使用样式导入，来让单独的wxss生效我们可以在一个wxss中导入另一个wxss文件： 使用@import进行导入 @import后跟需要导入的外联样式表的相对路径（或者绝对路径也可以），用;表示语句结束。可以在app.wxss中导入这个样式，也可以在page.wxss导入这个样式#####官方样式库为了减少开发者样式开发的工作量，小程序官方提供了WeUI.wxss基本样式库 WXML的基本语法WXML基本格式： 类似于HTML代码：比如可以写成单标签，也可以写成双标签 必须有严格的闭合：没有闭合会导致编译错误 大小写敏感：class和Class是不同的属性开发中, 界面上展示的数据并不是写死的, 而是会根据服务器返回的数据, 或者用户的操作来进行改变.如果使用原生JS或者jQuery的话, 我们需要通过操作DOM来进行界面的更新.小程序和Vue/React一样, 提供了插值语法: Mustache语法(双大括号)Mustache语法不仅仅可以直接显示数据, 也可以使用表达式,并且可以绑定到属性.逻辑判断 wx:if – wx:elif – wx:else某些时候, 我们需要根据条件来决定一些内容是否渲染：当条件为true时, view组件会渲染出来当条件为false时, view组件不会渲染出来有多个条件:使用wx:if-wx:elif-wx:elsehidden属性:hidden是所有的组件都默认拥有的属性,当hidden属性为true时, 组件会被隐藏当hidden属性为false时, 组件会显示出来hidden和wx:if的区别hidden控制隐藏和显示是控制是否添加hidden属性wx:if是控制组件是否渲染的 列表渲染 – wx:for基础我们知道，在实际开发中，服务器经常返回各种列表数据，我们不可能一一从列表中取出数据进行展示；需要通过for循环的方式，遍历所有的数据，一次性进行展示；在组件中，我们可以使用wx:for来遍历一个数组 （字符串 - 数字）默认情况下，遍历后在wxml中可以使用一个变量index，保存的是当前遍历数据的下标值。数组中对应某项的数据，使用变量名item获取。 block标签什么是block标签？某些情况下，我们需要使用 wx:if 或 wx:for时，可能需要包裹一组组件标签我们希望对这一组组件标签进行整体的操作，使用一个view标签或者block标签包裹 block标签的意义并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。12345678使用block有两个好处：1）将需要进行遍历或者判断的内容进行包裹。2）将遍历和判断的属性放在block便签中，不影响普通属性的阅读，提高代码的可读性。#### 列表渲染 – item/index名称默认情况下，item – index的名字是固定的但是某些情况下，我们可能想使用其他名称,或者当出现多层遍历时，名字会重复这个时候，我们可以指定item和index的名称,```wx:for-item=&quot;指定名称&quot;，wx:for-index=&quot;指定名称&quot; 列表渲染 – key作用这个其实和小程序内部也使用了虚拟DOM有关系（和Vue、React很相似）。当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点,我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的。即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？所以我们需要使用key来给每个节点做一个唯一标识Diff算法就可以正确的识别此节点,找到正确的位置区插入新的节点。所以一句话，key的作用主要是为了高效的更新虚拟DOM。 模板用法WXML提供模板（template），可以在模板中定义代码片段，在不同的地方调用。(是一种wxml代码的复用机制)  使用 name 属性，作为模板的名字, 然后在 &lt;template/&gt; 内定义代码片段 wxml的引入小程序wxml中提供了两种引入文件的方式：import和includeImport引入：import 可以在该文件中使用目标文件定义的 template注意：wxml中不能递归引入（也就是A引入了B的template，不会引入B中引入C的template）include引入:include 可以将目标文件中除了 &lt;template/&gt; &lt;wxs/&gt;外的整个代码引入，相当于是拷贝到 include 位置. wxs模块WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。 为什么要设计WXS语言呢？在WXML中是不能直接调用Page/Component中定义的函数的.但是某些情况, 我们可以希望使用函数来处理WXML中的数据(类似于Vue中的过滤器)，这个时候就使用WXS了.WXS使用的限制和特点： WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API。 WXS 函数不能作为组件的事件回调。 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。 WXS有两种写法： 写在&lt;wxs&gt;标签中 写在以.wxs结尾的文件中 5.组件化开发类似于页面，自定义组件由 json wxml wxss js 4个文件组成。 自定义组件的步骤：1.首先需要在 json 文件中进行自定义组件声明（将component 字段设为 true 可这一组文件设为自定义组件）：2.在wxml中编写属于我们组件自己的模板3.在wxss中编写属于我们组件自己的相关样式4.在js文件中, 可以定义数据或组件内部的相关逻辑(后续我们再使用) 使用自定义组件和细节注意事项一些需要注意的细节：因为 WXML 节点标签名只能是 小写字母、中划线和下划线 的组合，所以自定义组件的标签名也只能包含这些字符。自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用usingComponents 字段）。自定义组件和页面所在项目根目录名 不能以“wx-”为前缀，否则会报错。如果在app.json的usingComponents声明某个组件，那么所有页面和组件可以直接使用该组件。 组件的样式细节课题一：组件内的样式 对 外部样式 的影响结论一：组件内的class样式，只对组件wxml内的节点生效, 对于引用组件的Page页面不生效。结论二：组件内不能使用id选择器、属性选择器、标签选择器 课题二：外部样式 对 组件内样式 的影响结论一：外部使用class的样式，只对外部wxml的class生效，对组件内是不生效的结论二：外部使用了id选择器、属性选择器不会对组件内产生影响结论三：外部使用了标签选择器，会对组件内产生影响 整体结论:组件内的class样式和组件外的class样式, 默认是有一个隔离效果的；为了防止样式的错乱，官方不推荐使用id、属性、标签选择器； 课题三：如何让class可以相互影响在Component对象中，可以传入一个options属性，其中options属性中有一个styleIsolation（隔离）属性。styleIsolation有三个取值： isolated 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（默认取值）； apply-shared 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面； shared 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 其他一些相关样式细节，参考官网 组件和页面通信很多情况下，组件内展示的内容（数据、样式、标签），并不是在组件内写死的，而且可以由使用者来决定。 向组件传递数据 - properties给组件传递数据：大部分情况下，组件只负责布局和样式，内容是由使用组件的对象决定的。所以，我们经常需要从外部传递数据给我们的组件，让我们的组件来进行展示。如何传递呢？使用properties属性：支持的类型：String、Number、BooleanObject、Array、null（不限制类型） 向组件传递样式 - externalClasses给组件传递样式：有时候，我们不希望将样式在组件内固定不变，而是外部可以决定样式。这个时候，我们可以使用externalClasses属性：1.在Component对象中，定义externalClasses属性2.在组件内的wxml中使用externalClasses属性中的class3.在页面中传入对应的class，并且给这个class设置样式 组件向外传递事件 – 自定义事件有时候是自定义组件内部发生了事件，需要告知使用者，这个时候可以使用自定义事件页面直接调用组件方法:this.selectComponent 什么是插槽slot翻译为插槽：插槽的目的是让我们原来的设备具备更多的扩展性。 组件的插槽：组件的插槽也是为了让我们封装的组件更加具有扩展性。让使用者可以决定组件内部的一些内容到底展示什么。 单个插槽的使用除了内容和样式可能由外界决定之外，也可能外界想决定显示的方式比如我们有一个组件定义了头部和尾部，但是中间的内容可能是一段文字，也可能是一张图片，或者是一个进度条。在不确定外界想插入什么其他组件的前提下，我们可以在组件内预留插槽 多个插槽的使用有时候为了让组件更加灵活, 我们需要定义多个插槽： Component构造器Component构造器用户创建我们的自定义组件对象, 调用Component时, 可以传入属性、数据、方法等 小程序得系统API网络请求 – 基本使用微信提供了专属的API接口,用于网络请求: wx.request(Object object)比较关键的几个属性解析:url: 必传, 不然请求什么.data: 请求参数method: 请求的方式success: 成功时的回调fail: 失败时的回调 网络请求 – 请求封装目前我们采用的网络请求是非常古老的请求方式, 我们将它封装成Promise的方式。 展示弹窗小程序中展示弹窗有四种方式: showToast、showModal、showLoading、showActionSheet 页面分享分享是小程序扩散的一种重要方式，小程序中有两种分享方式：点击右上角的菜单按钮，之后点击转发，或者点击某一个按钮，直接转发当我们转发给好友一个小程序时，通常小程序中会显示一些信息：如何决定这些信息的展示呢？通过 onShareAppMessage 小程序的登录流程小程序登录流程图：1.调用wx.login获取code2.调用wx.request发送code到我们自己的服务器（我们自己的服务器会返回一个登录态的标识，比如token）3.将登录态的标识token进行存储，以便下次使用4.请求需要登录态标识的接口时，携带token 界面跳转界面的跳转有两种方式：通过navigator组件 和 通过wx的API跳转navigator组件主要就是用于界面的跳转的 open-type的取值：redirect：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面，并且不能返回。（不是一个压栈）switchTab：跳转到 tabBar 页面，并关闭其他所有非tabBar 页面。（需要在tabBar中定义的）eLaunch：关闭所有的页面，打开应用中某个页面。（直接展示某个页面，并且可以跳转到tabBar页面） 导航返回有两个属性来起作用：open-type：navigateBack（表示该navigator组件用于返回）delta：返回的层级（指定返回的层级，open-type必须是navigateBack才生效） 如何在界面跳转过程中我们需要相互传递一些数据，应该如何完成呢？ 数据传递 – 传递过程首页 -&gt; 详情页：通过修改URL传递参数详情页 -&gt; 首页：返回时携带数据有两个问题需要考虑 问题一: 在什么地方修改数据 如果你是监听按钮或者navigator的点击来返回时, 可以通过bindtap来映射到某个函数, 在函数中完成. 但是这种方式不能监听左上角返回按钮的点击. 所以我们选择在onUnload中修改数据问题二: 如何修改数据 小程序并没有提供直接修改数据的方法. 但是可以通过getCurrentPages来获取所有的页面, 然后使用页面对象的setData({})函数来修改 代码的跳转和返回很多情况下，我们并不喜欢使用navigator组件来进行跳转：可能我们希望用户点击了某个button或者view时，对该button或者view进行监听之后，通过相关的代码逻辑实现跳转对此，微信也提供了对应的API接口：wx.navigateTo(url[, ])wx.navigateBack([delta]) 至此微信小程序基础知识过了一遍，更多知识参考官方文档。（下面开始项目实战）","categories":[],"tags":[{"name":"小程序 微信","slug":"小程序-微信","permalink":"http://yoursite.com/tags/小程序-微信/"}]},{"title":"【转载】hexo 文章保存为草稿","slug":"hexo文章保存为草稿","date":"2019-09-12T07:40:45.000Z","updated":"2019-09-28T16:32:11.852Z","comments":true,"path":"2019/09/12/hexo文章保存为草稿/","link":"","permalink":"http://yoursite.com/2019/09/12/hexo文章保存为草稿/","excerpt":"转载自： https://novnan.github.io/Hexo/hexo-draft/","text":"转载自： https://novnan.github.io/Hexo/hexo-draft/ 传统建立文章方式一般我们都会使用 new ``` 来建立文章，这种建立方法会将新文章建立在 source/_posts 目录下，当使用 hexo generate 编译 markdown 文件时，会将其 HTML 结果编译在 public 目录下，之后 hexo deploy 将会把 public 目录下所有文章部署到 GitHub，这是我们熟悉的 Hexo 流程。12345这种建立文章方式的缺点是：若我们同时编辑多篇文章，只要其中一篇文章尚未编辑完成，也会随着 hexo deploy 一起部署到 GitHub，也就是 GitHub 可能会看到我们尚未完成的文章。## 建立文章草稿```$ hexo new draft &lt;title&gt; Hexo 另外提供 draft 机制，它的原理是新文章将建立在 source/_drafts 目录下，因此 hexo generate 并不会将其编译到 public 目录下，所以 hexo deploy 也不会将其部署到 GitHub。 本机预览草稿hexo S --draft```1234虽然 hexo generate 不会编译 source/_drafts 目录下的文章，但 Hexo 的 Hexo server 另外提供 --draft 参数，这让我们只要搭配 hexo-browsersync plugins，就可以达到一边编辑 markdown 文章，一边使用浏览器预览的目的。## 将草稿发布为正式文章```$ hexo P &lt;filename&gt; 其中 &lt;filename&gt; 为不包含 md 后缀的文章名称。它的原理只是将文章从 source/_drafts 移动到 source/_posts 而已。 之后的 hexo generate 与 hexo deploy 的用法就完全一样了。 若日后想将正式文章转为为草稿，只需手动将文章从 source/_posts 目录移动到 source/_drafts 目录即可。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"[终于创建好了我的博客]","slug":"终于创建好了我的博客","date":"2019-09-10T17:27:25.000Z","updated":"2019-09-26T13:47:37.067Z","comments":true,"path":"2019/09/11/终于创建好了我的博客/","link":"","permalink":"http://yoursite.com/2019/09/11/终于创建好了我的博客/","excerpt":"","text":"哈哈哈哈，兜兜转转，折腾了好久，换了好多种主题和Blog的框架终于搞定了自己的Blog，记录下自己。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]